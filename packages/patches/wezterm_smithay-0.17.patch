diff --git a/Cargo.lock b/Cargo.lock
index cbf03094881..9d35c4b48ed 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -3520,18 +3520,6 @@ dependencies = [
  "memoffset 0.6.5",
 ]
 
-[[package]]
-name = "nix"
-version = "0.24.3"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "fa52e972a9a719cecb6864fb88568781eb706bac2cd1d4f04a648542dbf78069"
-dependencies = [
- "bitflags 1.3.2",
- "cfg-if",
- "libc",
- "memoffset 0.6.5",
-]
-
 [[package]]
 name = "nix"
 version = "0.25.1"
@@ -4311,6 +4299,15 @@ dependencies = [
  "bytemuck",
 ]
 
+[[package]]
+name = "quick-xml"
+version = "0.28.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0ce5e73202a820a31f8a0ee32ada5e21029c81fd9e3ebf668a40832e4219d9d1"
+dependencies = [
+ "memchr",
+]
+
 [[package]]
 name = "quick-xml"
 version = "0.30.0"
@@ -5039,20 +5036,23 @@ checksum = "b7c388c1b5e93756d0c740965c41e8822f866621d41acbdf6336a6a168f8840c"
 
 [[package]]
 name = "smithay-client-toolkit"
-version = "0.16.1"
+version = "0.17.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "870427e30b8f2cbe64bf43ec4b86e88fe39b0a84b3f15efd9c9c2d020bc86eb9"
+checksum = "e1476c3d89bb67079264b88aaf4f14358353318397e083b7c4e8c14517f55de7"
 dependencies = [
  "bitflags 1.3.2",
  "dlib",
  "lazy_static",
  "log",
  "memmap2 0.5.10",
- "nix 0.24.3",
- "pkg-config",
+ "nix 0.26.4",
+ "thiserror",
+ "wayland-backend",
  "wayland-client",
  "wayland-cursor",
  "wayland-protocols",
+ "wayland-protocols-wlr",
+ "wayland-scanner",
 ]
 
 [[package]]
@@ -6098,84 +6098,97 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4d91413b1c31d7539ba5ef2451af3f0b833a005eb27a631cec32bc0635a8602b"
 
 [[package]]
-name = "wayland-client"
-version = "0.29.5"
+name = "wayland-backend"
+version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "3f3b068c05a039c9f755f881dc50f01732214f5685e379829759088967c46715"
+checksum = "41b48e27457e8da3b2260ac60d0a94512f5cba36448679f3747c0865b7893ed8"
 dependencies = [
- "bitflags 1.3.2",
+ "cc",
  "downcast-rs",
- "libc",
- "nix 0.24.3",
+ "io-lifetimes",
+ "nix 0.26.4",
  "scoped-tls",
- "wayland-commons",
- "wayland-scanner",
+ "smallvec",
  "wayland-sys",
 ]
 
 [[package]]
-name = "wayland-commons"
-version = "0.29.5"
+name = "wayland-client"
+version = "0.30.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8691f134d584a33a6606d9d717b95c4fa20065605f798a3f350d78dced02a902"
+checksum = "489c9654770f674fc7e266b3c579f4053d7551df0ceb392f153adb1f9ed06ac8"
 dependencies = [
- "nix 0.24.3",
- "once_cell",
- "smallvec",
- "wayland-sys",
+ "bitflags 1.3.2",
+ "nix 0.26.4",
+ "wayland-backend",
+ "wayland-scanner",
 ]
 
 [[package]]
 name = "wayland-cursor"
-version = "0.29.5"
+version = "0.30.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6865c6b66f13d6257bef1cd40cbfe8ef2f150fb8ebbdb1e8e873455931377661"
+checksum = "2d0c3a0d5b4b688b07b0442362d3ed6bf04724fcc16cd69ab6285b90dbc487aa"
 dependencies = [
- "nix 0.24.3",
+ "nix 0.26.4",
  "wayland-client",
  "xcursor",
 ]
 
 [[package]]
 name = "wayland-egl"
-version = "0.29.5"
+version = "0.30.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "402de949f81a012926d821a2d659f930694257e76dd92b6e0042ceb27be4107d"
+checksum = "1187695fe81c3153c3163f9d2953149f638c5d7dbc6fe988914ca3f4961e28ed"
 dependencies = [
- "wayland-client",
+ "wayland-backend",
  "wayland-sys",
 ]
 
 [[package]]
 name = "wayland-protocols"
-version = "0.29.5"
+version = "0.30.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "b950621f9354b322ee817a23474e479b34be96c2e909c14f7bc0100e9a970bc6"
+checksum = "3b28101e5ca94f70461a6c2d610f76d85ad223d042dd76585ab23d3422dd9b4d"
 dependencies = [
  "bitflags 1.3.2",
+ "wayland-backend",
  "wayland-client",
- "wayland-commons",
+ "wayland-scanner",
+]
+
+[[package]]
+name = "wayland-protocols-wlr"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fce991093320e4a6a525876e6b629ab24da25f9baef0c2e0080ad173ec89588a"
+dependencies = [
+ "bitflags 1.3.2",
+ "wayland-backend",
+ "wayland-client",
+ "wayland-protocols",
  "wayland-scanner",
 ]
 
 [[package]]
 name = "wayland-scanner"
-version = "0.29.5"
+version = "0.30.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "8f4303d8fa22ab852f789e75a967f0a2cdc430a607751c0499bada3e451cbd53"
+checksum = "b9b873b257fbc32ec909c0eb80dea312076a67014e65e245f5eb69a6b8ab330e"
 dependencies = [
  "proc-macro2",
+ "quick-xml 0.28.2",
  "quote",
- "xml-rs",
 ]
 
 [[package]]
 name = "wayland-sys"
-version = "0.29.5"
+version = "0.30.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "be12ce1a3c39ec7dba25594b97b42cb3195d54953ddb9d3d95a7c3902bc6e9d4"
+checksum = "96b2a02ac608e07132978689a6f9bf4214949c85998c247abadd4f4129b1aa06"
 dependencies = [
  "dlib",
+ "log",
  "pkg-config",
 ]
 
diff --git a/window/Cargo.toml b/window/Cargo.toml
index 218f2a17b78..5dd9e61fe45 100644
--- a/window/Cargo.toml
+++ b/window/Cargo.toml
@@ -75,10 +75,10 @@ xcb = {version="1.3", features=["render", "randr", "dri2", "xkb", "xlib_xcb", "p
 xkbcommon = { version = "0.7.0", features = ["x11", "wayland"] }
 mio = {version="0.8", features=["os-ext"]}
 libc = "0.2"
-smithay-client-toolkit = {version = "0.16.1", default-features=false, optional=true}
-wayland-protocols = {version="0.29", optional=true}
-wayland-client = {version="0.29", optional=true}
-wayland-egl = {version="0.29", optional=true}
+smithay-client-toolkit = {version = "0.17.0", default-features=false, optional=true}
+wayland-protocols = {version="0.30", optional=true}
+wayland-client = {version="0.30", optional=true}
+wayland-egl = {version="0.30", optional=true}
 xcb-imdkit = { version="0.3", git="https://github.com/wez/xcb-imdkit-rs.git", rev="215ce4b08ac9c4822e541efd4f4ffb1062806051"}
 zbus = "3.14"
 zvariant = "3.15"
diff --git a/window/src/os/wayland/connection.rs b/window/src/os/wayland/connection.rs
index e94e6d0c3da..f917bdfcadd 100644
--- a/window/src/os/wayland/connection.rs
+++ b/window/src/os/wayland/connection.rs
@@ -1,336 +1,131 @@
-#![allow(dead_code)]
-use super::pointer::*;
-use super::window::*;
-use crate::connection::ConnectionOps;
-use crate::os::wayland::inputhandler::InputHandler;
-use crate::os::wayland::output::OutputHandler;
-use crate::os::x11::keyboard::KeyboardWithFallback;
-use crate::screen::{ScreenInfo, Screens};
-use crate::spawn::*;
-use crate::{Appearance, Connection, ScreenRect, WindowEvent};
-use anyhow::{bail, Context};
-use mio::unix::SourceFd;
-use mio::{Events, Interest, Poll, Token};
-use smithay_client_toolkit as toolkit;
 use std::cell::RefCell;
 use std::collections::HashMap;
-use std::io::Read;
-use std::os::unix::fs::FileExt;
-use std::os::unix::io::FromRawFd;
+use std::os::fd::AsRawFd;
 use std::rc::Rc;
 use std::sync::atomic::AtomicUsize;
-use toolkit::environment::Environment;
-use toolkit::reexports::client::Display;
-use toolkit::seat::SeatListener;
-use toolkit::shm::AutoMemPool;
-use wayland_client::protocol::wl_keyboard::{Event as WlKeyboardEvent, KeymapFormat, WlKeyboard};
-use wayland_client::{EventQueue, Main};
-
-toolkit::default_environment!(MyEnvironment, desktop,
-fields=[
-    output_handler: OutputHandler,
-    input_handler: InputHandler,
-],
-singles=[
-    wayland_protocols::wlr::unstable::output_management::v1::client::zwlr_output_manager_v1::ZwlrOutputManagerV1 => output_handler,
-    wayland_protocols::unstable::text_input::v3::client::zwp_text_input_manager_v3::ZwpTextInputManagerV3 => input_handler,
-]);
-
-impl MyEnvironment {
-    pub fn input_handler(&mut self) -> &mut InputHandler {
-        &mut self.input_handler
-    }
-}
+
+use anyhow::{bail, Context};
+use mio::unix::SourceFd;
+use mio::{Events, Interest, Poll, Token};
+use wayland_client::backend::WaylandError;
+use wayland_client::globals::registry_queue_init;
+use wayland_client::{Connection as WConnection, EventQueue};
+
+use crate::screen::{ScreenInfo, Screens};
+use crate::spawn::SPAWN_QUEUE;
+use crate::{Connection, ConnectionOps, ScreenRect};
+
+use super::state::WaylandState;
+use super::WaylandWindowInner;
 
 pub struct WaylandConnection {
-    should_terminate: RefCell<bool>,
+    pub(crate) should_terminate: RefCell<bool>,
     pub(crate) next_window_id: AtomicUsize,
-    pub(crate) windows: RefCell<HashMap<usize, Rc<RefCell<WaylandWindowInner>>>>,
-
-    // Take care with the destruction order: the underlying wayland
-    // libraries are not safe and require destruction in reverse
-    // creation order.  This list of fields must reflect that otherwise
-    // we'll segfault on shutdown.
-    // Rust guarantees that struct fields are dropped in the order
-    // they appear in the struct, so the Display must be at the
-    // bottom of this list, and opengl, which depends on everything
-    // must be ahead of the rest.
-    pub(crate) gl_connection: RefCell<Option<Rc<crate::egl::GlConnection>>>,
-    pub(crate) pointer: RefCell<PointerDispatcher>,
-    pub(crate) keyboard_mapper: RefCell<Option<KeyboardWithFallback>>,
-    pub(crate) keyboard_window_id: RefCell<Option<usize>>,
-    pub(crate) surface_to_window_id: RefCell<HashMap<u32, usize>>,
-    pub(crate) active_surface_id: RefCell<u32>,
-
-    /// Repeats per second
-    pub(crate) key_repeat_rate: RefCell<i32>,
-
-    pub(crate) mem_pool: RefCell<AutoMemPool>,
-
-    /// Delay before repeating, in milliseconds
-    pub(crate) key_repeat_delay: RefCell<i32>,
-    pub(crate) last_serial: RefCell<u32>,
-    seat_listener: SeatListener,
-    pub(crate) environment: Environment<MyEnvironment>,
-    event_q: RefCell<EventQueue>,
-    pub(crate) display: RefCell<Display>,
+    pub(super) gl_connection: RefCell<Option<Rc<crate::egl::GlConnection>>>,
+    pub(super) connection: WConnection,
+    pub(super) event_queue: RefCell<EventQueue<WaylandState>>,
+    pub(super) wayland_state: RefCell<WaylandState>,
 }
 
-impl Drop for WaylandConnection {
-    fn drop(&mut self) {
-        self.environment
-            .with_inner(|env| env.input_handler.shutdown());
+impl WaylandConnection {
+    pub(crate) fn create_new() -> anyhow::Result<Self> {
+        let conn = WConnection::connect_to_env()?;
+        let (globals, event_queue) = registry_queue_init::<WaylandState>(&conn)?;
+        let qh = event_queue.handle();
+
+        let wayland_state = WaylandState::new(&globals, &qh)?;
+        let wayland_connection = WaylandConnection {
+            connection: conn,
+            should_terminate: RefCell::new(false),
+            next_window_id: AtomicUsize::new(1),
+            gl_connection: RefCell::new(None),
+            event_queue: RefCell::new(event_queue),
+            wayland_state: RefCell::new(wayland_state),
+        };
+
+        Ok(wayland_connection)
     }
-}
 
-impl WaylandConnection {
-    pub fn create_new() -> anyhow::Result<Self> {
-        let (environment, display, event_q) = toolkit::new_default_environment!(
-            MyEnvironment,
-            desktop,
-            fields = [
-                output_handler: OutputHandler::new(),
-                input_handler: InputHandler::new(),
-            ]
+    pub(crate) fn advise_of_appearance_change(&self, _appearance: crate::Appearance) {}
+
+    fn run_message_loop_impl(&self) -> anyhow::Result<()> {
+        const TOK_WL: usize = 0xffff_fffc;
+        const TOK_SPAWN: usize = 0xffff_fffd;
+        let tok_wl = Token(TOK_WL);
+        let tok_spawn = Token(TOK_SPAWN);
+
+        let mut poll = Poll::new()?;
+        let mut events = Events::with_capacity(8);
+
+        let wl_fd = {
+            let read_guard = self.event_queue.borrow().prepare_read()?;
+            read_guard.connection_fd().as_raw_fd()
+        };
+
+        poll.registry()
+            .register(&mut SourceFd(&wl_fd), tok_wl, Interest::READABLE)?;
+        poll.registry().register(
+            &mut SourceFd(&SPAWN_QUEUE.raw_fd()),
+            tok_spawn,
+            Interest::READABLE,
         )?;
 
-        let mut pointer = None;
-        let mut seat_keyboards = HashMap::new();
-
-        for seat in environment.get_all_seats() {
-            if let Some((has_kbd, has_ptr, name)) =
-                toolkit::seat::with_seat_data(&seat, |seat_data| {
-                    (
-                        seat_data.has_keyboard && !seat_data.defunct,
-                        seat_data.has_pointer && !seat_data.defunct,
-                        seat_data.name.clone(),
-                    )
-                })
+        while !*self.should_terminate.borrow() {
+            let timeout = if SPAWN_QUEUE.run() {
+                Some(std::time::Duration::from_secs(0))
+            } else {
+                None
+            };
+
+            let mut event_q = self.event_queue.borrow_mut();
             {
-                if has_kbd {
-                    let keyboard = seat.get_keyboard();
-                    keyboard.quick_assign(|keyboard, event, _| {
-                        let conn = Connection::get().unwrap().wayland();
-                        if let Err(err) = conn.keyboard_event(keyboard, event) {
-                            log::error!("keyboard_event: {:#}", err);
-                        }
-                    });
-                    environment.with_inner(|env| env.input_handler.advise_seat(&seat, &keyboard));
-                    seat_keyboards.insert(name, keyboard);
-                }
-                if has_ptr {
-                    pointer.replace(PointerDispatcher::register(
-                        &seat,
-                        environment.require_global(),
-                        environment.require_global(),
-                        environment.require_global(),
-                        environment.get_primary_selection_manager(),
-                    )?);
+                let mut wayland_state = self.wayland_state.borrow_mut();
+                if let Err(err) = event_q.dispatch_pending(&mut wayland_state) {
+                    // TODO: show the protocol error in the display
+                    return Err(err)
+                        .with_context(|| format!("error during event_q.dispatch protcol_error"));
                 }
             }
-        }
-        let pointer =
-            pointer.ok_or_else(|| anyhow::anyhow!("no seats have an available pointer"))?;
-
-        let seat_listener;
-        {
-            let env = environment.clone();
-            seat_listener = environment.listen_for_seats(move |seat, seat_data, _| {
-                if seat_data.has_keyboard {
-                    if !seat_data.defunct {
-                        // We only want to assign a new keyboard object if we don't already have
-                        // one for this seat. When a seat is being created or updated, the listener
-                        // can receive the same seat multiple times: for example, when switching
-                        // back from another virtual console, the same seat is usually seen four
-                        // times with different data flags:
-                        //
-                        // has_pointer: true;  has_keyboard: false
-                        // has_pointer: false; has_keyboard: false
-                        // has_pointer: false; has_keyboard: true
-                        // has_pointer: true;  has_keyboard: true
-                        //
-                        // This is essentially telling the client to re-assign its keyboard and
-                        // pointer, but that means that this listener will fire twice with
-                        // has_keyboard set to true. If we assign a handler both times, then we end
-                        // up handling key events twice.
-                        if !seat_keyboards.contains_key(&seat_data.name) {
-                            let keyboard = seat.get_keyboard();
-
-                            keyboard.quick_assign(|keyboard, event, _| {
-                                let conn = Connection::get().unwrap().wayland();
-                                if let Err(err) = conn.keyboard_event(keyboard, event) {
-                                    log::error!("keyboard_event: {:#}", err);
-                                }
-                            });
-                            env.with_inner(|env| env.input_handler.advise_seat(&seat, &keyboard));
-                            seat_keyboards.insert(seat_data.name.clone(), keyboard);
-                        }
-                    } else {
-                        env.with_inner(|env| env.input_handler.seat_defunct(&seat));
-                    }
-                } else {
-                    // If we previously had a keyboard object on this seat, it's no longer valid if
-                    // has_keyboard is false, so we remove the keyboard object we knew about and
-                    // thereby ensure that we assign a new keyboard object next time the listener
-                    // fires for this seat with has_keyboard = true.
-                    seat_keyboards.remove(&seat_data.name);
-                }
-                if seat_data.has_pointer && !seat_data.defunct {
-                    let conn = Connection::get().unwrap().wayland();
-                    conn.pointer.borrow_mut().seat_changed(&seat);
-                }
-            });
-        }
-
-        let mem_pool = environment.create_auto_pool()?;
 
-        Ok(Self {
-            display: RefCell::new(display),
-            environment,
-            should_terminate: RefCell::new(false),
-            next_window_id: AtomicUsize::new(1),
-            windows: RefCell::new(HashMap::new()),
-            event_q: RefCell::new(event_q),
-            pointer: RefCell::new(pointer),
-            seat_listener,
-            mem_pool: RefCell::new(mem_pool),
-            gl_connection: RefCell::new(None),
-            keyboard_mapper: RefCell::new(None),
-            key_repeat_rate: RefCell::new(25),
-            key_repeat_delay: RefCell::new(400),
-            keyboard_window_id: RefCell::new(None),
-            last_serial: RefCell::new(0),
-            surface_to_window_id: RefCell::new(HashMap::new()),
-            active_surface_id: RefCell::new(0),
-        })
-    }
-
-    fn keyboard_event(
-        &self,
-        keyboard: Main<WlKeyboard>,
-        event: WlKeyboardEvent,
-    ) -> anyhow::Result<()> {
-        match &event {
-            WlKeyboardEvent::Enter {
-                serial, surface, ..
-            } => {
-                // update global active surface id
-                *self.active_surface_id.borrow_mut() = surface.as_ref().id();
-
-                *self.last_serial.borrow_mut() = *serial;
-                if let Some(&window_id) = self
-                    .surface_to_window_id
-                    .borrow()
-                    .get(&surface.as_ref().id())
-                {
-                    self.keyboard_window_id.borrow_mut().replace(window_id);
-                    self.environment.with_inner(|env| {
-                        if let Some(input) =
-                            env.input_handler.get_text_input_for_keyboard(&keyboard)
-                        {
-                            input.enable();
-                            input.commit();
-                        }
-                        env.input_handler.advise_surface(&surface, &keyboard);
-                    });
-                } else {
-                    log::warn!("{:?}, no known surface", event);
+            event_q.flush()?;
+            if let Err(err) = poll.poll(&mut events, timeout) {
+                if err.kind() == std::io::ErrorKind::Interrupted {
+                    continue;
                 }
+                bail!("polling for events: {:?}", err);
             }
-            WlKeyboardEvent::Leave { serial, .. } => {
-                if let Some(input) = self
-                    .environment
-                    .with_inner(|env| env.input_handler.get_text_input_for_keyboard(&keyboard))
-                {
-                    input.disable();
-                    input.commit();
+
+            for event in &events {
+                if event.token() != tok_wl {
+                    continue;
                 }
-                *self.last_serial.borrow_mut() = *serial;
-            }
-            WlKeyboardEvent::Key { serial, .. } | WlKeyboardEvent::Modifiers { serial, .. } => {
-                *self.last_serial.borrow_mut() = *serial;
-            }
-            WlKeyboardEvent::RepeatInfo { rate, delay } => {
-                *self.key_repeat_rate.borrow_mut() = *rate;
-                *self.key_repeat_delay.borrow_mut() = *delay;
-            }
-            WlKeyboardEvent::Keymap { format, fd, size } => {
-                let mut file = unsafe { std::fs::File::from_raw_fd(*fd) };
-                match format {
-                    KeymapFormat::XkbV1 => {
-                        let mut data = vec![0u8; *size as usize];
-                        // If we weren't passed a pipe, be sure to explicitly
-                        // read from the start of the file
-                        match file.read_exact_at(&mut data, 0) {
-                            Ok(_) => {}
-                            Err(err) => {
-                                // ideally: we check for:
-                                // err.kind() == std::io::ErrorKind::NotSeekable
-                                // but that is not yet in stable rust
-                                if err.raw_os_error() == Some(libc::ESPIPE) {
-                                    // It's a pipe, which cannot be seeked, so we
-                                    // just try reading from the current pipe position
-                                    file.read(&mut data).context("read from Keymap fd/pipe")?;
-                                } else {
-                                    return Err(err).context("read_exact_at from Keymap fd");
-                                }
-                            }
-                        }
-                        // Dance around CString panicing on the NUL terminator
-                        // in the xkbcommon crate
-                        while let Some(0) = data.last() {
-                            data.pop();
-                        }
-                        let s = String::from_utf8(data)?;
-                        match KeyboardWithFallback::new_from_string(s) {
-                            Ok(k) => {
-                                self.keyboard_mapper.replace(Some(k));
-                            }
-                            Err(err) => {
-                                log::error!("Error processing keymap change: {:#}", err);
-                            }
+
+                if let Ok(guard) = event_q.prepare_read() {
+                    if let Err(err) = guard.read() {
+                        log::trace!("Event Q error: {:?}", err);
+                        if let WaylandError::Protocol(perr) = err {
+                            return Err(perr.into());
+                            // TODO
+                            // return Err(perr).with_context(|| {
+                            //     format!("error during event_q.read protocol_error={:?}",
+                            //             perr)
+                            // })
                         }
                     }
-                    _ => {}
                 }
             }
-            _ => {}
-        }
-        if let Some(&window_id) = self.keyboard_window_id.borrow().as_ref() {
-            if let Some(win) = self.window_by_id(window_id) {
-                let mut inner = win.borrow_mut();
-                inner.keyboard_event(event);
-            }
         }
 
         Ok(())
     }
 
-    pub(crate) fn dispatch_to_focused_window(&self, event: WindowEvent) {
-        if let Some(&window_id) = self.keyboard_window_id.borrow().as_ref() {
-            if let Some(win) = self.window_by_id(window_id) {
-                let mut inner = win.borrow_mut();
-                inner.events.dispatch(event);
-            }
-        }
-    }
-
     pub(crate) fn next_window_id(&self) -> usize {
         self.next_window_id
             .fetch_add(1, ::std::sync::atomic::Ordering::Relaxed)
     }
 
-    fn flush(&self) -> anyhow::Result<()> {
-        if let Err(e) = self.display.borrow_mut().flush() {
-            if e.kind() != ::std::io::ErrorKind::WouldBlock {
-                bail!("Error while flushing display: {}", e);
-            }
-        }
-        Ok(())
-    }
-
     pub(crate) fn window_by_id(&self, window_id: usize) -> Option<Rc<RefCell<WaylandWindowInner>>> {
-        self.windows.borrow().get(&window_id).map(Rc::clone)
+        self.wayland_state.borrow().window_by_id(window_id)
     }
 
     pub(crate) fn with_window_inner<
@@ -356,87 +151,6 @@ impl WaylandConnection {
 
         future
     }
-
-    fn run_message_loop_impl(&self) -> anyhow::Result<()> {
-        const TOK_WL: usize = 0xffff_fffc;
-        const TOK_SPAWN: usize = 0xffff_fffd;
-        let tok_wl = Token(TOK_WL);
-        let tok_spawn = Token(TOK_SPAWN);
-
-        let mut poll = Poll::new()?;
-        let mut events = Events::with_capacity(8);
-        poll.registry().register(
-            &mut SourceFd(&self.display.borrow().get_connection_fd()),
-            tok_wl,
-            Interest::READABLE,
-        )?;
-        poll.registry().register(
-            &mut SourceFd(&SPAWN_QUEUE.raw_fd()),
-            tok_spawn,
-            Interest::READABLE,
-        )?;
-
-        while !*self.should_terminate.borrow() {
-            // Check the spawn queue before we try to sleep; there may
-            // be work pending and we don't guarantee that there is a
-            // 1:1 wakeup to queued function, so we need to be assertive
-            // in order to avoid missing wakeups
-            let timeout = if SPAWN_QUEUE.run() {
-                // if we processed one, we don't want to sleep because
-                // there may be others to deal with
-                Some(std::time::Duration::from_secs(0))
-            } else {
-                None
-            };
-
-            {
-                let mut event_q = self.event_q.borrow_mut();
-                if let Err(err) = event_q.dispatch_pending(&mut (), |_, _, _| {}) {
-                    return Err(err).with_context(|| {
-                        format!(
-                            "error during event_q.dispatch protocol_error={:?}",
-                            self.display.borrow().protocol_error()
-                        )
-                    });
-                }
-            }
-
-            self.flush()?;
-            if let Err(err) = poll.poll(&mut events, timeout) {
-                if err.kind() == std::io::ErrorKind::Interrupted {
-                    continue;
-                }
-                bail!("polling for events: {:?}", err);
-            }
-
-            for event in &events {
-                if event.token() == tok_wl {
-                    let event_q = self.event_q.borrow();
-                    if let Some(guard) = event_q.prepare_read() {
-                        if let Err(err) = guard.read_events() {
-                            if err.kind() != std::io::ErrorKind::WouldBlock
-                                && err.kind() != std::io::ErrorKind::Interrupted
-                            {
-                                return Err(err).with_context(|| {
-                                    format!(
-                                        "error during event_q.read_events protocol_error={:?}",
-                                        self.display.borrow().protocol_error()
-                                    )
-                                });
-                            }
-                        }
-                    }
-                }
-            }
-        }
-        Ok(())
-    }
-
-    pub(crate) fn advise_of_appearance_change(&self, appearance: crate::Appearance) {
-        for win in self.windows.borrow().values() {
-            win.borrow_mut().appearance_changed(appearance);
-        }
-    }
 }
 
 impl ConnectionOps for WaylandConnection {
@@ -445,86 +159,77 @@ impl ConnectionOps for WaylandConnection {
     }
 
     fn terminate_message_loop(&self) {
+        log::trace!("Terminating Message Loop");
         *self.should_terminate.borrow_mut() = true;
     }
 
-    fn get_appearance(&self) -> Appearance {
-        match promise::spawn::block_on(crate::os::xdg_desktop_portal::get_appearance()) {
-            Ok(Some(appearance)) => return appearance,
-            Ok(None) => {}
-            Err(err) => {
-                log::debug!("Unable to resolve appearance using xdg-desktop-portal: {err:#}");
-            }
-        }
-        // fallback
-        Appearance::Light
-    }
-
     fn run_message_loop(&self) -> anyhow::Result<()> {
         let res = self.run_message_loop_impl();
         // Ensure that we drop these eagerly, to avoid
         // noisy errors wrt. global destructors unwinding
         // in unexpected places
-        self.windows.borrow_mut().clear();
+        self.wayland_state.borrow().windows.borrow_mut().clear();
         res
     }
 
-    fn screens(&self) -> anyhow::Result<Screens> {
-        if let Some(screens) = self
-            .environment
-            .with_inner(|env| env.output_handler.screens())
-        {
-            return Ok(screens);
+    fn screens(&self) -> anyhow::Result<crate::screen::Screens> {
+        log::trace!("Getting screens for wayland connection");
+
+        if let Some(output_manager) = &self.wayland_state.borrow().output_manager {
+            if let Some(screens) = output_manager.screens() {
+                return Ok(screens);
+            }
         }
 
         let mut by_name = HashMap::new();
         let mut virtual_rect: ScreenRect = euclid::rect(0, 0, 0, 0);
         let config = config::configuration();
-        for output in self.environment.get_all_outputs() {
-            toolkit::output::with_output_info(&output, |info| {
-                let name = if info.name.is_empty() {
-                    format!("{} {}", info.model, info.make)
-                } else {
-                    info.name.clone()
-                };
-
-                let (width, height) = info
-                    .modes
-                    .iter()
-                    .find(|mode| mode.is_current)
-                    .map(|mode| mode.dimensions)
-                    .unwrap_or((info.physical_size.0, info.physical_size.1));
-
-                let rect = euclid::rect(
-                    info.location.0 as isize,
-                    info.location.1 as isize,
-                    width as isize,
-                    height as isize,
-                );
-
-                let scale = info.scale_factor as f64;
-
-                // FIXME: teach this how to resolve dpi_by_screen once
-                // dispatch_pending_event knows how to do the same
-                let effective_dpi = Some(config.dpi.unwrap_or(scale * crate::DEFAULT_DPI));
-
-                virtual_rect = virtual_rect.union(&rect);
-                by_name.insert(
-                    name.clone(),
-                    ScreenInfo {
-                        name,
-                        rect,
-                        scale,
-                        max_fps: None,
-                        effective_dpi,
-                    },
-                );
-            });
+
+        let output_state = &self.wayland_state.borrow().output;
+
+        for output in output_state.outputs() {
+            let info = output_state.info(&output).unwrap();
+            let name = match info.name {
+                Some(n) => n.clone(),
+                None => format!("{} {}", info.model, info.make),
+            };
+
+            let (width, height) = info
+                .modes
+                .iter()
+                .find(|mode| mode.current)
+                .map(|mode| mode.dimensions)
+                .unwrap_or((info.physical_size.0, info.physical_size.1));
+
+            let rect = euclid::rect(
+                info.location.0 as isize,
+                info.location.1 as isize,
+                width as isize,
+                height as isize,
+            );
+
+            let scale = info.scale_factor as f64;
+
+            // FIXME: teach this how to resolve dpi_by_screen once
+            // dispatch_pending_event knows how to do the same
+            let effective_dpi = Some(config.dpi.unwrap_or(scale * crate::DEFAULT_DPI));
+
+            virtual_rect = virtual_rect.union(&rect);
+            by_name.insert(
+                name.clone(),
+                ScreenInfo {
+                    name,
+                    rect,
+                    scale,
+                    max_fps: None,
+                    effective_dpi,
+                },
+            );
         }
 
-        // The main screen is the one either at the origin of
-        // the virtual area, or if that doesn't exist for some weird
-        // reason, the screen closest to the origin.
+        // // The main screen is the one either at the origin of
+        // // the virtual area, or if that doesn't exist for some weird
+        // // reason, the screen closest to the origin.
         let main = by_name
             .values()
             .min_by_key(|screen| {
diff --git a/window/src/os/wayland/copy_and_paste.rs b/window/src/os/wayland/copy_and_paste.rs
index 4cacd204896..ad83e462b68 100644
--- a/window/src/os/wayland/copy_and_paste.rs
+++ b/window/src/os/wayland/copy_and_paste.rs
@@ -1,17 +1,22 @@
-use anyhow::{anyhow, bail, Context, Error};
+use anyhow::{anyhow, Error, bail};
 use filedescriptor::{FileDescriptor, Pipe};
 use smithay_client_toolkit as toolkit;
+use toolkit::globals::GlobalData;
+use wayland_client::{Dispatch, event_created_child};
+use wayland_client::globals::{GlobalList, BindError};
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_device_manager_v1::ZwpPrimarySelectionDeviceManagerV1;
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_device_v1::{ZwpPrimarySelectionDeviceV1, self, Event as PrimarySelectionDeviceEvent};
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_offer_v1::{ZwpPrimarySelectionOfferV1, Event as PrimarySelectionOfferEvent};
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_source_v1::{ZwpPrimarySelectionSourceV1, Event as PrimarySelectionSourceEvent};
 use std::io::Write;
-use std::os::unix::io::AsRawFd;
-use std::os::unix::prelude::{FromRawFd, IntoRawFd};
+use std::os::fd::{AsRawFd, FromRawFd, IntoRawFd};
 use std::sync::{Arc, Mutex};
-use toolkit::primary_selection::*;
-use toolkit::reexports::client::protocol::wl_data_offer::{Event as DataOfferEvent, WlDataOffer};
-use wayland_client::protocol::wl_data_device_manager::WlDataDeviceManager;
-use wayland_client::protocol::wl_data_source::Event as DataSourceEvent;
+use toolkit::reexports::client::protocol::wl_data_offer::WlDataOffer;
 
-use crate::connection::ConnectionOps;
-use crate::Clipboard;
+use crate::{Clipboard, ConnectionOps};
+
+use super::data_device::TEXT_MIME_TYPE;
+use super::state::WaylandState;
 
 #[derive(Default)]
 pub struct CopyAndPaste {
@@ -26,32 +31,33 @@ impl std::fmt::Debug for CopyAndPaste {
     }
 }
 
-pub const TEXT_MIME_TYPE: &str = "text/plain;charset=utf-8";
-
 impl CopyAndPaste {
-    pub fn create() -> Arc<Mutex<Self>> {
+    pub(super) fn create() -> Arc<Mutex<Self>> {
         Arc::new(Mutex::new(Default::default()))
     }
 
-    pub fn get_clipboard_data(&mut self, clipboard: Clipboard) -> anyhow::Result<FileDescriptor> {
+    pub(super) fn get_clipboard_data(
+        &mut self,
+        clipboard: Clipboard,
+    ) -> anyhow::Result<FileDescriptor> {
         let conn = crate::Connection::get().unwrap().wayland();
-        let pointer = conn.pointer.borrow();
+        let wayland_state = conn.wayland_state.borrow();
         let primary_selection = if let Clipboard::PrimarySelection = clipboard {
-            pointer.primary_selection_device.as_ref()
+            wayland_state.primary_selection_manager.as_ref()
         } else {
             None
         };
+
         match primary_selection {
-            Some(device) => {
-                let pipe = device.with_selection(|offer| {
-                    offer
-                        .ok_or_else(|| anyhow!("no primary selection offer"))
-                        .and_then(|o| {
-                            o.receive(TEXT_MIME_TYPE.to_string())
-                                .with_context(|| "failed to open read pipe".to_string())
-                        })
-                })?;
-                Ok(unsafe { FileDescriptor::from_raw_fd(pipe.into_raw_fd()) })
+            Some(primary_selection) => {
+                let inner = primary_selection.inner.lock().unwrap();
+                let offer = inner
+                    .offer
+                    .as_ref()
+                    .ok_or_else(|| anyhow!("no primary selection offer"))?;
+                let pipe = Pipe::new().map_err(Error::msg)?;
+                offer.receive(TEXT_MIME_TYPE.to_string(), pipe.write.as_raw_fd());
+                Ok(pipe.read)
             }
             None => {
                 let offer = self
@@ -65,87 +71,58 @@ impl CopyAndPaste {
         }
     }
 
-    pub fn set_clipboard_data(&mut self, clipboard: Clipboard, data: String) {
+    pub(super) fn set_clipboard_data(&mut self, clipboard: Clipboard, data: String) {
         let conn = crate::Connection::get().unwrap().wayland();
-        let last_serial = *conn.last_serial.borrow();
-        let pointer = conn.pointer.borrow();
+        let qh = conn.event_queue.borrow().handle();
+        let mut wayland_state = conn.wayland_state.borrow_mut();
+        let last_serial = *wayland_state.last_serial.borrow();
+
         let primary_selection = if let Clipboard::PrimarySelection = clipboard {
-            conn.environment
-                .get_primary_selection_manager()
-                .zip(pointer.primary_selection_device.as_ref())
+            wayland_state.primary_selection_manager.as_ref()
         } else {
             None
         };
 
         match primary_selection {
-            Some((manager, device)) => {
-                let source = PrimarySelectionSource::new(
-                    &manager,
-                    &[TEXT_MIME_TYPE.to_string()],
-                    move |event, _dispatch_data| match event {
-                        PrimarySelectionSourceEvent::Cancelled => {
-                            crate::Connection::get()
-                                .unwrap()
-                                .wayland()
-                                .pointer
-                                .borrow()
-                                .data_device
-                                .set_selection(None, 0);
-                        }
-                        PrimarySelectionSourceEvent::Send { pipe, .. } => {
-                            let fd = unsafe { FileDescriptor::from_raw_fd(pipe.into_raw_fd()) };
-                            write_selection_to_pipe(fd, &data);
-                        }
-                    },
-                );
-                device.set_selection(&Some(source), last_serial)
+            Some(primary_selection) => {
+                let manager = &primary_selection.manager;
+                let selection_device = wayland_state.primary_select_device.as_ref().unwrap();
+                let source = manager.create_source(&qh, PrimarySelectionManagerData::default());
+                source.offer(TEXT_MIME_TYPE.to_string());
+                selection_device.set_selection(Some(&source), last_serial);
+                wayland_state
+                    .primary_selection_source
+                    .replace((source, data));
             }
             None => {
-                let source = conn
-                    .environment
-                    .require_global::<WlDataDeviceManager>()
-                    .create_data_source();
-                source.quick_assign(move |_source, event, _dispatch_data| {
-                    if let DataSourceEvent::Send { fd, .. } = event {
-                        let fd = unsafe { FileDescriptor::from_raw_fd(fd) };
-                        write_selection_to_pipe(fd, &data);
-                    }
-                });
-                source.offer(TEXT_MIME_TYPE.to_string());
-                conn.pointer
-                    .borrow()
-                    .data_device
-                    .set_selection(Some(&source), last_serial);
+                let data_device = &wayland_state.data_device;
+                let source = wayland_state
+                    .data_device_manager_state
+                    .create_copy_paste_source(&qh, vec![TEXT_MIME_TYPE]);
+                source.set_selection(data_device.as_ref().unwrap(), last_serial);
+                wayland_state.copy_paste_source.replace((source, data));
             }
         }
     }
 
-    pub fn handle_data_offer(&mut self, event: DataOfferEvent, offer: WlDataOffer) {
-        match event {
-            DataOfferEvent::Offer { mime_type } => {
-                let conn = crate::Connection::get().unwrap().wayland();
-                let last_serial = *conn.last_serial.borrow();
-                if mime_type == TEXT_MIME_TYPE {
-                    offer.accept(last_serial, Some(mime_type));
-                    self.data_offer.replace(offer);
-                } else {
-                    // Refuse other mime types
-                    offer.accept(last_serial, None);
-                }
-            }
-            DataOfferEvent::SourceActions { .. } | DataOfferEvent::Action { .. } => {
-                // ignore drag and drop events
-            }
-            _ => {}
-        }
+    pub(super) fn confirm_selection(&mut self, offer: WlDataOffer) {
+        self.data_offer.replace(offer);
     }
+}
 
-    pub fn confirm_selection(&mut self, offer: WlDataOffer) {
-        self.data_offer.replace(offer);
+impl WaylandState {
+    pub(super) fn resolve_copy_and_paste(&mut self) -> Option<Arc<Mutex<CopyAndPaste>>> {
+        let active_surface_id = self.active_surface_id.borrow();
+        let active_surface_id = active_surface_id.as_ref().unwrap();
+        if let Some(pending) = self.surface_to_pending.get(&active_surface_id) {
+            Some(Arc::clone(&pending.lock().unwrap().copy_and_paste))
+        } else {
+            None
+        }
     }
 }
 
-fn write_selection_to_pipe(fd: FileDescriptor, text: &str) {
+pub(super) fn write_selection_to_pipe(fd: FileDescriptor, text: &str) {
     if let Err(e) = write_pipe_with_timeout(fd, text.as_bytes()) {
         log::error!("while sending primary selection to pipe: {}", e);
     }
@@ -179,3 +156,151 @@ fn write_pipe_with_timeout(mut file: FileDescriptor, data: &[u8]) -> anyhow::Res
 
     Ok(())
 }
+
+// Smithay has their own primary selection handler in 0.18
+// Some code borrowed from https://github.com/Smithay/client-toolkit/commit/4a5c4f59f640bc588a55277261bbed1bd2abea98
+pub(super) struct PrimarySelectionManagerState {
+    pub(super) manager: ZwpPrimarySelectionDeviceManagerV1,
+    inner: Mutex<PrimaryInner>,
+}
+
+#[derive(Default, Debug)]
+struct PrimaryInner {
+    pending_offer: Option<ZwpPrimarySelectionOfferV1>,
+    offer: Option<ZwpPrimarySelectionOfferV1>,
+    valid_mime: bool,
+}
+
+#[derive(Default)]
+pub(super) struct PrimarySelectionManagerData {}
+
+impl PrimarySelectionManagerState {
+    pub(super) fn bind(
+        globals: &GlobalList,
+        queue_handle: &wayland_client::QueueHandle<WaylandState>,
+    ) -> Result<Self, BindError> {
+        let manager = globals.bind(queue_handle, 1..=1, GlobalData)?;
+        Ok(Self {
+            manager,
+            inner: Mutex::new(PrimaryInner::default()),
+        })
+    }
+}
+
+impl Dispatch<ZwpPrimarySelectionDeviceManagerV1, GlobalData, WaylandState>
+    for PrimarySelectionManagerState
+{
+    fn event(
+        _state: &mut WaylandState,
+        _proxy: &ZwpPrimarySelectionDeviceManagerV1,
+        _event: <ZwpPrimarySelectionDeviceManagerV1 as wayland_client::Proxy>::Event,
+        _data: &GlobalData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        unreachable!("primary selection manager has no events");
+    }
+}
+
+impl Dispatch<ZwpPrimarySelectionSourceV1, PrimarySelectionManagerData, WaylandState>
+    for PrimarySelectionManagerState
+{
+    fn event(
+        state: &mut WaylandState,
+        source: &ZwpPrimarySelectionSourceV1,
+        event: <ZwpPrimarySelectionSourceV1 as wayland_client::Proxy>::Event,
+        _data: &PrimarySelectionManagerData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        match event {
+            PrimarySelectionSourceEvent::Send { mime_type, fd } => {
+                if mime_type != TEXT_MIME_TYPE {
+                    return;
+                };
+
+                if let Some((ps_source, data)) = &state.primary_selection_source {
+                    if ps_source != source {
+                        return;
+                    }
+                    let fd = unsafe { FileDescriptor::from_raw_fd(fd.into_raw_fd()) };
+                    write_selection_to_pipe(fd, data);
+                }
+            }
+            PrimarySelectionSourceEvent::Cancelled => {
+                state.primary_selection_source.take();
+                source.destroy();
+            }
+            _ => unreachable!(),
+        }
+    }
+}
+
+impl Dispatch<ZwpPrimarySelectionOfferV1, PrimarySelectionManagerData, WaylandState>
+    for PrimarySelectionManagerState
+{
+    fn event(
+        state: &mut WaylandState,
+        _proxy: &ZwpPrimarySelectionOfferV1,
+        event: <ZwpPrimarySelectionOfferV1 as wayland_client::Proxy>::Event,
+        _data: &PrimarySelectionManagerData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        match event {
+            PrimarySelectionOfferEvent::Offer { mime_type } => {
+                if mime_type == TEXT_MIME_TYPE {
+                    let mgr = state.primary_selection_manager.as_ref().unwrap();
+                    let mut inner = mgr.inner.lock().unwrap();
+                    inner.valid_mime = true;
+                }
+            }
+            _ => unreachable!(),
+        }
+    }
+}
+
+impl Dispatch<ZwpPrimarySelectionDeviceV1, PrimarySelectionManagerData, WaylandState>
+    for PrimarySelectionManagerState
+{
+    event_created_child!(WaylandState, ZwpPrimarySelectionDeviceV1, [
+        zwp_primary_selection_device_v1::EVT_DATA_OFFER_OPCODE => (ZwpPrimarySelectionOfferV1, PrimarySelectionManagerData::default())
+    ]);
+
+    fn event(
+        state: &mut WaylandState,
+        _primary_selection_device: &ZwpPrimarySelectionDeviceV1,
+        event: <ZwpPrimarySelectionDeviceV1 as wayland_client::Proxy>::Event,
+        _data: &PrimarySelectionManagerData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        let psm = state.primary_selection_manager.as_ref().unwrap();
+        let mut inner = psm.inner.lock().unwrap();
+        match event {
+            PrimarySelectionDeviceEvent::DataOffer { offer } => {
+                inner.pending_offer = Some(offer);
+            }
+            PrimarySelectionDeviceEvent::Selection { id } => {
+                if !inner.valid_mime {
+                    return;
+                }
+
+                if let Some(offer) = inner.offer.take() {
+                    offer.destroy();
+                }
+                if id == inner.pending_offer {
+                    inner.offer = inner.pending_offer.take();
+                } else {
+                    // Remove the pending offer, assign the new delivered one.
+                    if let Some(offer) = inner.pending_offer.take() {
+                        offer.destroy()
+                    }
+
+                    inner.offer = id;
+                }
+            }
+            _ => unreachable!(),
+        }
+    }
+}
diff --git a/window/src/os/wayland/data_device.rs b/window/src/os/wayland/data_device.rs
new file mode 100644
index 00000000000..d14857df1b0
--- /dev/null
+++ b/window/src/os/wayland/data_device.rs
@@ -0,0 +1,240 @@
+use std::os::fd::{FromRawFd, IntoRawFd};
+
+use filedescriptor::FileDescriptor;
+use smithay_client_toolkit::data_device_manager::data_device::{
+    DataDevice, DataDeviceDataExt, DataDeviceHandler,
+};
+use smithay_client_toolkit::data_device_manager::data_offer::DataOfferHandler;
+use smithay_client_toolkit::data_device_manager::data_source::DataSourceHandler;
+use smithay_client_toolkit::data_device_manager::WritePipe;
+use wayland_client::protocol::wl_data_device_manager::DndAction;
+use wayland_client::Proxy;
+
+use crate::wayland::drag_and_drop::SurfaceAndOffer;
+use crate::wayland::pointer::PointerUserData;
+use crate::wayland::SurfaceUserData;
+
+use super::copy_and_paste::write_selection_to_pipe;
+use super::drag_and_drop::{DragAndDrop, SurfaceAndPipe};
+use super::state::WaylandState;
+
+pub(super) const TEXT_MIME_TYPE: &str = "text/plain;charset=utf-8";
+pub(super) const URI_MIME_TYPE: &str = "text/uri-list";
+
+impl DataDeviceHandler for WaylandState {
+    fn enter(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        data_device: DataDevice,
+    ) {
+        let mut drag_offer = data_device.drag_offer().unwrap();
+        log::trace!(
+            "Data offer entered: {:?}, mime_types: {:?}",
+            drag_offer,
+            data_device.drag_mime_types()
+        );
+
+        if let Some(m) = data_device
+            .drag_mime_types()
+            .iter()
+            .find(|s| *s == URI_MIME_TYPE)
+        {
+            drag_offer.accept_mime_type(*self.last_serial.borrow(), Some(m.clone()));
+        }
+
+        drag_offer.set_actions(DndAction::None | DndAction::Copy, DndAction::None);
+
+        let pointer = self.pointer.as_mut().unwrap();
+        let mut pstate = pointer
+            .pointer()
+            .data::<PointerUserData>()
+            .unwrap()
+            .state
+            .lock()
+            .unwrap();
+
+        let offer = drag_offer.inner().clone();
+        let window_id = SurfaceUserData::from_wl(&drag_offer.surface).window_id;
+
+        pstate.drag_and_drop.offer = Some(SurfaceAndOffer { window_id, offer });
+    }
+
+    fn leave(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _data_device: DataDevice,
+    ) {
+        let pointer = self.pointer.as_mut().unwrap();
+        let mut pstate = pointer
+            .pointer()
+            .data::<PointerUserData>()
+            .unwrap()
+            .state
+            .lock()
+            .unwrap();
+        if let Some(SurfaceAndOffer { offer, .. }) = pstate.drag_and_drop.offer.take() {
+            offer.destroy();
+        }
+    }
+
+    fn motion(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _data_device: DataDevice,
+    ) {
+    }
+
+    fn selection(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        data_device: DataDevice,
+    ) {
+        let mime_types = data_device.selection_mime_types();
+        if !mime_types.iter().any(|s| s == TEXT_MIME_TYPE) {
+            return;
+        }
+
+        if let Some(offer) = data_device.selection_offer() {
+            if let Some(copy_and_paste) = self.resolve_copy_and_paste() {
+                copy_and_paste
+                    .lock()
+                    .unwrap()
+                    .confirm_selection(offer.inner().clone());
+            }
+        }
+    }
+
+    fn drop_performed(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _data_device: DataDevice,
+    ) {
+        let pointer = self.pointer.as_mut().unwrap();
+        let mut pstate = pointer
+            .pointer()
+            .data::<PointerUserData>()
+            .unwrap()
+            .state
+            .lock()
+            .unwrap();
+        let drag_and_drop = &mut pstate.drag_and_drop;
+        if let Some(SurfaceAndPipe { window_id, read }) = drag_and_drop.create_pipe_for_drop() {
+            std::thread::spawn(move || {
+                if let Some(paths) = DragAndDrop::read_paths_from_pipe(read) {
+                    DragAndDrop::dispatch_dropped_files(window_id, paths);
+                }
+            });
+        }
+        // if let Some(SurfaceAndOffer { offer, .. }) = pstate.drag_and_drop.offer.take() {
+    }
+}
+
+impl DataOfferHandler for WaylandState {
+    fn offer(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        offer: &mut smithay_client_toolkit::data_device_manager::data_offer::DataDeviceOffer,
+        mime_type: String,
+    ) {
+        log::trace!("Received offer with mime type: {mime_type}");
+        if mime_type == TEXT_MIME_TYPE {
+            offer.accept_mime_type(*self.last_serial.borrow(), Some(mime_type));
+        } else {
+            // Refuse other mime types
+            offer.accept_mime_type(*self.last_serial.borrow(), None);
+        }
+    }
+
+    // Ignore drag and drop events
+    fn source_actions(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _offer: &mut smithay_client_toolkit::data_device_manager::data_offer::DragOffer,
+        _actions: wayland_client::protocol::wl_data_device_manager::DndAction,
+    ) {
+    }
+
+    fn selected_action(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _offer: &mut smithay_client_toolkit::data_device_manager::data_offer::DragOffer,
+        _actions: wayland_client::protocol::wl_data_device_manager::DndAction,
+    ) {
+    }
+}
+
+// We seem to to ignore all events other than sending_request and cancelled
+impl DataSourceHandler for WaylandState {
+    fn accept_mime(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _source: &wayland_client::protocol::wl_data_source::WlDataSource,
+        _mime: Option<String>,
+    ) {
+    }
+
+    fn send_request(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        source: &wayland_client::protocol::wl_data_source::WlDataSource,
+        mime: String,
+        fd: WritePipe,
+    ) {
+        if mime != TEXT_MIME_TYPE {
+            return;
+        }
+
+        if let Some((cp_source, data)) = &self.copy_paste_source {
+            if cp_source.inner() != source {
+                return;
+            }
+            let fd = unsafe { FileDescriptor::from_raw_fd(fd.into_raw_fd()) };
+            write_selection_to_pipe(fd, data);
+        }
+    }
+
+    fn cancelled(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        source: &wayland_client::protocol::wl_data_source::WlDataSource,
+    ) {
+        self.copy_paste_source.take();
+        source.destroy();
+    }
+
+    fn dnd_dropped(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _source: &wayland_client::protocol::wl_data_source::WlDataSource,
+    ) {
+    }
+
+    fn dnd_finished(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _source: &wayland_client::protocol::wl_data_source::WlDataSource,
+    ) {
+    }
+
+    fn action(
+        &mut self,
+        _conn: &wayland_client::Connection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _source: &wayland_client::protocol::wl_data_source::WlDataSource,
+        _action: wayland_client::protocol::wl_data_device_manager::DndAction,
+    ) {
+    }
+}
diff --git a/window/src/os/wayland/drag_and_drop.rs b/window/src/os/wayland/drag_and_drop.rs
index 2df5030f8b4..59dbfbe400d 100644
--- a/window/src/os/wayland/drag_and_drop.rs
+++ b/window/src/os/wayland/drag_and_drop.rs
@@ -1,46 +1,45 @@
-use crate::connection::ConnectionOps;
-use crate::wayland::{read_pipe_with_timeout, WaylandConnection};
+use crate::wayland::read_pipe_with_timeout;
+use crate::ConnectionOps;
 use filedescriptor::{FileDescriptor, Pipe};
 use smithay_client_toolkit as toolkit;
 use std::os::unix::io::AsRawFd;
 use std::path::PathBuf;
-use toolkit::reexports::client::protocol::wl_data_device::Event as DataDeviceEvent;
 use toolkit::reexports::client::protocol::wl_data_offer::WlDataOffer;
 use url::Url;
-use wayland_client::protocol::wl_data_device_manager::DndAction;
+
+use super::data_device::URI_MIME_TYPE;
+use super::WaylandConnection;
 
 #[derive(Default)]
 pub struct DragAndDrop {
-    offer: Option<SurfaceAndOffer>,
+    pub(super) offer: Option<SurfaceAndOffer>,
 }
 
-struct SurfaceAndOffer {
-    surface_id: u32,
-    offer: WlDataOffer,
+pub(super) struct SurfaceAndOffer {
+    pub(super) window_id: usize,
+    pub(super) offer: WlDataOffer,
 }
 
-struct SurfaceAndPipe {
-    surface_id: u32,
-    read: FileDescriptor,
+pub(super) struct SurfaceAndPipe {
+    pub(super) window_id: usize,
+    pub(super) read: FileDescriptor,
 }
 
-pub const URI_MIME_TYPE: &str = "text/uri-list";
-
 impl DragAndDrop {
     /// Takes the current offer, if any, and initiates a receive into a pipe,
     /// returning that surface and pipe descriptor.
-    fn create_pipe_for_drop(&mut self) -> Option<SurfaceAndPipe> {
-        let SurfaceAndOffer { surface_id, offer } = self.offer.take()?;
+    pub(super) fn create_pipe_for_drop(&mut self) -> Option<SurfaceAndPipe> {
+        let SurfaceAndOffer { window_id, offer } = self.offer.take()?;
         let pipe = Pipe::new()
             .map_err(|err| log::error!("Unable to create pipe: {:#}", err))
             .ok()?;
         offer.receive(URI_MIME_TYPE.to_string(), pipe.write.as_raw_fd());
         let read = pipe.read;
         offer.finish();
-        Some(SurfaceAndPipe { surface_id, read })
+        Some(SurfaceAndPipe { window_id, read })
     }
 
-    fn read_paths_from_pipe(read: FileDescriptor) -> Option<Vec<PathBuf>> {
+    pub(super) fn read_paths_from_pipe(read: FileDescriptor) -> Option<Vec<PathBuf>> {
         read_pipe_with_timeout(read)
             .map_err(|err| {
                 log::error!("Error while reading pipe from drop result: {:#}", err);
@@ -68,52 +67,14 @@ impl DragAndDrop {
             .into()
     }
 
-    fn dispatch_dropped_files(surface_id: u32, paths: Vec<PathBuf>) {
+    pub(super) fn dispatch_dropped_files(window_id: usize, paths: Vec<PathBuf>) {
         promise::spawn::spawn_into_main_thread(async move {
             let conn = WaylandConnection::get().unwrap().wayland();
-            if let Some(&window_id) = conn.surface_to_window_id.borrow().get(&surface_id) {
-                if let Some(handle) = conn.window_by_id(window_id) {
-                    let mut inner = handle.borrow_mut();
-                    inner.dispatch_dropped_files(paths);
-                }
-            };
+            if let Some(handle) = conn.window_by_id(window_id) {
+                let mut inner = handle.borrow_mut();
+                inner.dispatch_dropped_files(paths);
+            }
         })
         .detach();
     }
-
-    pub fn handle_data_event(&mut self, event: DataDeviceEvent) {
-        match event {
-            DataDeviceEvent::Enter {
-                serial,
-                surface,
-                id,
-                ..
-            } => {
-                if let Some(offer) = id {
-                    offer.accept(serial, Some(URI_MIME_TYPE.to_string()));
-                    offer.set_actions(DndAction::None | DndAction::Copy, DndAction::None);
-                    self.offer = Some(SurfaceAndOffer {
-                        surface_id: surface.as_ref().id(),
-                        offer,
-                    });
-                }
-            }
-            DataDeviceEvent::Leave => {
-                if let Some(SurfaceAndOffer { offer, .. }) = self.offer.take() {
-                    offer.destroy();
-                }
-            }
-            DataDeviceEvent::Motion { .. } => {}
-            DataDeviceEvent::Drop => {
-                if let Some(SurfaceAndPipe { surface_id, read }) = self.create_pipe_for_drop() {
-                    std::thread::spawn(move || {
-                        if let Some(paths) = Self::read_paths_from_pipe(read) {
-                            Self::dispatch_dropped_files(surface_id, paths);
-                        }
-                    });
-                }
-            }
-            _ => {}
-        }
-    }
 }
diff --git a/window/src/os/wayland/inputhandler.rs b/window/src/os/wayland/inputhandler.rs
index 5e280a6ebd5..357d941f174 100644
--- a/window/src/os/wayland/inputhandler.rs
+++ b/window/src/os/wayland/inputhandler.rs
@@ -1,148 +1,89 @@
 //! Implements zwp_text_input_v3 for handling IME
-use crate::connection::ConnectionOps;
-use crate::os::wayland::{wl_id, WaylandConnection};
-use crate::{DeadKeyStatus, KeyCode, KeyEvent, Modifiers, WindowEvent};
-use smithay_client_toolkit::environment::GlobalHandler;
+use std::borrow::Borrow;
 use std::collections::HashMap;
-use std::sync::{Arc, Mutex};
+use std::sync::Mutex;
+
+use smithay_client_toolkit::globals::GlobalData;
+use wayland_client::backend::ObjectId;
+use wayland_client::globals::{BindError, GlobalList};
 use wayland_client::protocol::wl_keyboard::WlKeyboard;
-use wayland_client::protocol::wl_registry::WlRegistry;
 use wayland_client::protocol::wl_seat::WlSeat;
 use wayland_client::protocol::wl_surface::WlSurface;
-use wayland_client::{Attached, DispatchData, Main};
-use wayland_protocols::unstable::text_input::v3::client::zwp_text_input_manager_v3::ZwpTextInputManagerV3;
-use wayland_protocols::unstable::text_input::v3::client::zwp_text_input_v3::{
-    Event, ZwpTextInputV3,
+use wayland_client::{Dispatch, Proxy, QueueHandle};
+use wayland_protocols::wp::text_input::zv3::client::zwp_text_input_manager_v3::ZwpTextInputManagerV3;
+use wayland_protocols::wp::text_input::zv3::client::zwp_text_input_v3::{
+    Event as TextInputEvent, ZwpTextInputV3,
 };
-use wezterm_input_types::KeyboardLedStatus;
+use wezterm_input_types::{KeyCode, KeyEvent, KeyboardLedStatus, Modifiers};
+
+use crate::{DeadKeyStatus, WindowEvent};
 
-#[derive(Default, Debug)]
+use super::state::WaylandState;
+
+#[derive(Clone, Default, Debug)]
 struct PendingState {
     pre_edit: Option<String>,
     commit: Option<String>,
 }
 
-#[derive(Debug, Default)]
-struct Inner {
-    input_by_seat: HashMap<u32, Attached<ZwpTextInputV3>>,
-    keyboard_to_seat: HashMap<u32, u32>,
-    surface_to_keyboard: HashMap<u32, u32>,
-    pending_state: HashMap<u32, PendingState>,
+pub(super) struct TextInputState {
+    text_input_manager: ZwpTextInputManagerV3,
+    inner: Mutex<Inner>,
 }
 
-impl Inner {
-    fn handle_event(
-        &mut self,
-        input: Main<ZwpTextInputV3>,
-        event: Event,
-        _ddata: DispatchData,
-        _inner: &Arc<Mutex<Self>>,
-    ) {
-        log::trace!("{event:?}");
-        let conn = WaylandConnection::get().unwrap().wayland();
-        let pending_state = self.pending_state.entry(wl_id(&**input)).or_default();
-        match event {
-            Event::PreeditString {
-                text,
-                cursor_begin: _,
-                cursor_end: _,
-            } => {
-                pending_state.pre_edit = text;
-            }
-            Event::CommitString { text } => {
-                pending_state.commit = text;
-                conn.dispatch_to_focused_window(WindowEvent::AdviseDeadKeyStatus(
-                    DeadKeyStatus::None,
-                ));
-            }
-            Event::Done { serial } => {
-                *conn.last_serial.borrow_mut() = serial;
-                if let Some(text) = pending_state.commit.take() {
-                    conn.dispatch_to_focused_window(WindowEvent::KeyEvent(KeyEvent {
-                        key: KeyCode::composed(&text),
-                        modifiers: Modifiers::NONE,
-                        leds: KeyboardLedStatus::empty(),
-                        repeat_count: 1,
-                        key_is_down: true,
-                        raw: None,
-                    }));
-                }
-                let status = if let Some(text) = pending_state.pre_edit.take() {
-                    DeadKeyStatus::Composing(text)
-                } else {
-                    DeadKeyStatus::None
-                };
-                conn.dispatch_to_focused_window(WindowEvent::AdviseDeadKeyStatus(status));
-            }
-            _ => {}
-        }
-    }
-
-    fn disable_all(&mut self) {
-        for input in self.input_by_seat.values() {
-            input.disable();
-            input.commit();
-        }
-    }
-}
-
-pub struct InputHandler {
-    mgr: Option<Attached<ZwpTextInputManagerV3>>,
-    inner: Arc<Mutex<Inner>>,
+#[derive(Debug, Default)]
+struct Inner {
+    input_by_seat: HashMap<ObjectId, ZwpTextInputV3>,
+    keyboard_to_seat: HashMap<ObjectId, ObjectId>,
+    surface_to_keyboard: HashMap<ObjectId, ObjectId>,
+    pending_state: HashMap<ObjectId, PendingState>,
 }
 
-impl InputHandler {
-    pub fn new() -> Self {
-        Self {
-            mgr: None,
-            inner: Arc::new(Mutex::new(Inner::default())),
-        }
+impl TextInputState {
+    pub(super) fn bind(
+        globals: &GlobalList,
+        queue_handle: &QueueHandle<WaylandState>,
+    ) -> Result<Self, BindError> {
+        let text_input_manager = globals.bind(queue_handle, 1..=1, GlobalData)?;
+        Ok(Self {
+            text_input_manager,
+            inner: Mutex::new(Inner::default()),
+        })
     }
 
-    pub fn get_text_input_for_keyboard(
-        &self,
-        keyboard: &WlKeyboard,
-    ) -> Option<Attached<ZwpTextInputV3>> {
+    pub fn get_text_input_for_keyboard(&self, keyboard: &WlKeyboard) -> Option<ZwpTextInputV3> {
         let inner = self.inner.lock().unwrap();
-        let keyboard_id = wl_id(keyboard);
+        let keyboard_id = keyboard.id();
         let seat_id = inner.keyboard_to_seat.get(&keyboard_id)?;
         inner.input_by_seat.get(&seat_id).cloned()
     }
 
-    pub fn get_text_input_for_surface(
-        &self,
-        surface: &WlSurface,
-    ) -> Option<Attached<ZwpTextInputV3>> {
+    pub(super) fn get_text_input_for_surface(&self, surface: &WlSurface) -> Option<ZwpTextInputV3> {
         let inner = self.inner.lock().unwrap();
-        let surface_id = wl_id(surface);
+        let surface_id = surface.id();
         let keyboard_id = inner.surface_to_keyboard.get(&surface_id)?;
         let seat_id = inner.keyboard_to_seat.get(&keyboard_id)?;
         inner.input_by_seat.get(&seat_id).cloned()
     }
 
-    pub fn get_text_input_for_seat(&self, seat: &WlSeat) -> Option<Attached<ZwpTextInputV3>> {
-        let mgr = self.mgr.as_ref()?;
+    fn get_text_input_for_seat(
+        &self,
+        seat: &WlSeat,
+        qh: &QueueHandle<WaylandState>,
+    ) -> Option<ZwpTextInputV3> {
+        let mgr = &self.text_input_manager;
         let mut inner = self.inner.lock().unwrap();
-        let seat_id = wl_id(seat);
+        let seat_id = seat.id();
         let input = inner.input_by_seat.entry(seat_id).or_insert_with(|| {
-            let input = mgr.get_text_input(seat);
-            let inner = Arc::clone(&self.inner);
-
-            input.quick_assign(move |input, event, ddat| {
-                inner
-                    .lock()
-                    .unwrap()
-                    .handle_event(input, event, ddat, &inner);
-            });
-
+            let input = mgr.get_text_input(seat, &qh, TextInputData::default());
             input.into()
         });
         Some(input.clone())
     }
 
-    pub fn advise_surface(&self, surface: &WlSurface, keyboard: &WlKeyboard) {
-        let surface_id = wl_id(surface);
-        let keyboard_id = wl_id(keyboard);
+    pub(super) fn advise_surface(&self, surface: &WlSurface, keyboard: &WlKeyboard) {
+        let surface_id = surface.id();
+        let keyboard_id = keyboard.id();
         self.inner
             .lock()
             .unwrap()
@@ -150,10 +91,15 @@ impl InputHandler {
             .insert(surface_id, keyboard_id);
     }
 
-    pub fn advise_seat(&self, seat: &WlSeat, keyboard: &WlKeyboard) {
-        self.get_text_input_for_seat(seat);
-        let keyboard_id = wl_id(keyboard);
-        let seat_id = wl_id(seat);
+    pub(super) fn advise_seat(
+        &self,
+        seat: &WlSeat,
+        keyboard: &WlKeyboard,
+        qh: &QueueHandle<WaylandState>,
+    ) {
+        self.get_text_input_for_seat(seat, qh);
+        let keyboard_id = keyboard.id();
+        let seat_id = seat.id();
         self.inner
             .lock()
             .unwrap()
@@ -167,27 +113,119 @@ impl InputHandler {
     pub fn shutdown(&self) {
         self.inner.lock().unwrap().disable_all();
     }
+}
 
-    pub fn seat_defunct(&self, seat: &WlSeat) {
-        let seat_id = wl_id(seat);
-        self.inner.lock().unwrap().input_by_seat.remove(&seat_id);
+impl Inner {
+    fn disable_all(&mut self) {
+        for input in self.input_by_seat.values() {
+            input.disable();
+            input.commit();
+        }
     }
 }
 
-impl GlobalHandler<ZwpTextInputManagerV3> for InputHandler {
-    fn created(
-        &mut self,
-        registry: Attached<WlRegistry>,
-        id: u32,
-        version: u32,
-        _ddata: DispatchData,
+#[derive(Default)]
+pub(super) struct TextInputData {
+    // XXX: inner could probably be moved here
+    _inner: Mutex<TextInputDataInner>,
+}
+
+#[derive(Default)]
+pub(super) struct TextInputDataInner {}
+
+impl Dispatch<ZwpTextInputManagerV3, GlobalData, WaylandState> for TextInputState {
+    fn event(
+        _state: &mut WaylandState,
+        _proxy: &ZwpTextInputManagerV3,
+        _event: <ZwpTextInputManagerV3 as Proxy>::Event,
+        _data: &GlobalData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &QueueHandle<WaylandState>,
     ) {
-        log::debug!("created ZwpTextInputV3 {id} {version}");
-        let mgr = registry.bind::<ZwpTextInputManagerV3>(1, id);
-        self.mgr.replace(mgr.into());
+        // No events from ZwpTextInputMangerV3
+        unreachable!();
     }
+}
+
+impl Dispatch<ZwpTextInputV3, TextInputData, WaylandState> for TextInputState {
+    fn event(
+        state: &mut WaylandState,
+        input: &ZwpTextInputV3,
+        event: <ZwpTextInputV3 as Proxy>::Event,
+        _data: &TextInputData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &QueueHandle<WaylandState>,
+    ) {
+        log::trace!("ZwpTextInputEvent: {event:?}");
+        let mut pending_state = {
+            let text_input = state.text_input.as_mut().unwrap();
+            let mut inner = text_input.inner.lock().unwrap();
+            inner.pending_state.entry(input.id()).or_default().clone()
+        };
 
-    fn get(&self) -> std::option::Option<Attached<ZwpTextInputManagerV3>> {
-        self.mgr.clone()
+        match event {
+            TextInputEvent::PreeditString {
+                text,
+                cursor_begin: _,
+                cursor_end: _,
+            } => {
+                pending_state.pre_edit = text;
+            }
+            TextInputEvent::CommitString { text } => {
+                pending_state.commit = text;
+                state.dispatch_to_focused_window(WindowEvent::AdviseDeadKeyStatus(
+                    DeadKeyStatus::None,
+                ));
+            }
+            TextInputEvent::Done { serial } => {
+                *state.last_serial.borrow_mut() = serial;
+                if let Some(text) = pending_state.commit.take() {
+                    state.dispatch_to_focused_window(WindowEvent::KeyEvent(KeyEvent {
+                        key: KeyCode::composed(&text),
+                        modifiers: Modifiers::NONE,
+                        leds: KeyboardLedStatus::empty(),
+                        repeat_count: 1,
+                        key_is_down: true,
+                        raw: None,
+                    }));
+                }
+                let status = if let Some(text) = pending_state.pre_edit.take() {
+                    DeadKeyStatus::Composing(text)
+                } else {
+                    DeadKeyStatus::None
+                };
+                state.dispatch_to_focused_window(WindowEvent::AdviseDeadKeyStatus(status));
+            }
+            _ => {}
+        }
+
+        state
+            .text_input
+            .as_ref()
+            .unwrap()
+            .inner
+            .lock()
+            .unwrap()
+            .pending_state
+            .insert(input.id(), pending_state);
+    }
+}
+
+impl WaylandState {
+    fn dispatch_to_focused_window(&self, event: WindowEvent) {
+        if let Some(&window_id) = self.keyboard_window_id.borrow().as_ref() {
+            if let Some(win) = self.window_by_id(window_id) {
+                let mut inner = win.borrow_mut();
+                inner.events.dispatch(event);
+            }
+        }
+    }
+}
+
+impl Drop for WaylandState {
+    fn drop(&mut self) {
+        if let Some(text_input) = self.text_input.as_mut() {
+            text_input.shutdown();
+        }
     }
 }
diff --git a/window/src/os/wayland/keyboard.rs b/window/src/os/wayland/keyboard.rs
new file mode 100644
index 00000000000..e9c03ddafb8
--- /dev/null
+++ b/window/src/os/wayland/keyboard.rs
@@ -0,0 +1,119 @@
+use std::borrow::BorrowMut;
+use std::io::Read;
+use std::os::fd::{AsRawFd, FromRawFd};
+use std::os::unix::fs::FileExt;
+
+use wayland_client::protocol::wl_keyboard::{Event as WlKeyboardEvent, KeymapFormat, WlKeyboard};
+use wayland_client::{Dispatch, Proxy};
+
+use crate::x11::KeyboardWithFallback;
+
+use super::state::WaylandState;
+use super::SurfaceUserData;
+
+// We can't use the xkbcommon feature because it is too abstract for us
+impl Dispatch<WlKeyboard, KeyboardData> for WaylandState {
+    fn event(
+        state: &mut WaylandState,
+        keyboard: &WlKeyboard,
+        event: <WlKeyboard as wayland_client::Proxy>::Event,
+        _data: &KeyboardData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        log::trace!("We reached an event here: {:?}???", event);
+        match &event {
+            WlKeyboardEvent::Enter {
+                serial, surface, ..
+            } => {
+                *state.active_surface_id.borrow_mut() = Some(surface.id());
+                *state.last_serial.borrow_mut() = *serial;
+                if let Some(sud) = SurfaceUserData::try_from_wl(&surface) {
+                    let window_id = sud.window_id;
+                    state.keyboard_window_id.borrow_mut().replace(window_id);
+                    if let Some(text_input) = &state.text_input {
+                        if let Some(input) = text_input.get_text_input_for_keyboard(keyboard) {
+                            input.enable();
+                            input.commit();
+                        }
+                        text_input.advise_surface(surface, keyboard);
+                    }
+                } else {
+                    log::warn!("{:?}, no known surface", event);
+                }
+            }
+            WlKeyboardEvent::Leave { serial, .. } => {
+                *state.last_serial.borrow_mut() = *serial;
+                if let Some(text_input) = &state.text_input {
+                    if let Some(input) = text_input.get_text_input_for_keyboard(keyboard) {
+                        input.disable();
+                        input.commit();
+                    }
+                }
+            }
+            WlKeyboardEvent::Key { serial, .. } | WlKeyboardEvent::Modifiers { serial, .. } => {
+                *state.last_serial.borrow_mut() = *serial;
+            }
+            WlKeyboardEvent::RepeatInfo { rate, delay } => {
+                *state.key_repeat_rate.borrow_mut() = *rate;
+                *state.key_repeat_delay.borrow_mut() = *delay;
+            }
+            WlKeyboardEvent::Keymap { format, fd, size } => {
+                let mut file = unsafe { std::fs::File::from_raw_fd(fd.as_raw_fd()) };
+                match format.into_result().unwrap() {
+                    KeymapFormat::XkbV1 => {
+                        let mut data = vec![0u8; *size as usize];
+                        // If we weren't passed a pipe, be sure to explicitly
+                        // read from the start of the file
+                        match file.read_exact_at(&mut data, 0) {
+                            Ok(_) => {}
+                            Err(err) => {
+                                // ideally: we check for:
+                                // err.kind() == std::io::ErrorKind::NotSeekable
+                                // but that is not yet in stable rust
+                                if err.raw_os_error() == Some(libc::ESPIPE) {
+                                    // It's a pipe, which cannot be seeked, so we
+                                    // just try reading from the current pipe position
+                                    file.read(&mut data).expect("read from Keymap fd/pipe");
+                                } else {
+                                    return Err(err).expect("read_exact_at from Keymap fd");
+                                }
+                            }
+                        }
+                        // Dance around CString panicing on the NUL terminator
+                        // in the xkbcommon crate
+                        while let Some(0) = data.last() {
+                            data.pop();
+                        }
+                        let s = String::from_utf8(data).expect("Failed to read string from data");
+                        match KeyboardWithFallback::new_from_string(s) {
+                            Ok(k) => {
+                                state.keyboard_mapper.replace(k);
+                            }
+                            Err(err) => {
+                                log::error!("Error processing keymap change: {:#}", err);
+                            }
+                        }
+                    }
+                    _ => {}
+                }
+            }
+            _ => {
+                unimplemented!()
+            }
+        }
+
+        let Some(&window_id) = state.keyboard_window_id.as_ref() else {
+            return;
+        };
+        let Some(win) = state.window_by_id(window_id) else {
+            return;
+        };
+        let mut inner = win.as_ref().borrow_mut();
+        let mapper = state.keyboard_mapper.borrow_mut();
+        let mapper = mapper.as_mut().expect("no keymap");
+        inner.keyboard_event(mapper, event);
+    }
+}
+
+pub(super) struct KeyboardData {}
diff --git a/window/src/os/wayland/mod.rs b/window/src/os/wayland/mod.rs
index a904110a6fd..0a88143c832 100644
--- a/window/src/os/wayland/mod.rs
+++ b/window/src/os/wayland/mod.rs
@@ -9,18 +9,9 @@ pub use connection::*;
 pub use output::*;
 mod copy_and_paste;
 mod drag_and_drop;
-mod frame;
+// mod frame;
+mod data_device;
+mod keyboard;
 mod pointer;
-
-/// Returns the id of a wayland proxy object, suitable for using
-/// a key into hash maps
-pub fn wl_id<I, T>(obj: T) -> u32
-where
-    I: wayland_client::Interface,
-    T: AsRef<wayland_client::Proxy<I>>,
-    I: AsRef<wayland_client::Proxy<I>>,
-    I: From<wayland_client::Proxy<I>>,
-{
-    let proxy: &wayland_client::Proxy<I> = obj.as_ref();
-    proxy.id()
-}
+mod seat;
+mod state;
diff --git a/window/src/os/wayland/output.rs b/window/src/os/wayland/output.rs
index 9970d9af405..0cb64f551ab 100644
--- a/window/src/os/wayland/output.rs
+++ b/window/src/os/wayland/output.rs
@@ -1,27 +1,23 @@
 //! Dealing with Wayland outputs
 
-use crate::os::wayland::wl_id;
 use crate::screen::{ScreenInfo, Screens};
 use crate::ScreenRect;
-use smithay_client_toolkit::environment::GlobalHandler;
+use smithay_client_toolkit::globals::GlobalData;
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_head_v1::{ZwlrOutputHeadV1, self, Event as ZwlrOutputHeadEvent};
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_manager_v1::{ZwlrOutputManagerV1, self, Event as ZwlrOutputEvent};
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_mode_v1::{ZwlrOutputModeV1, Event as ZwlrOutputModeEvent};
+use wayland_client::{Dispatch, event_created_child, Proxy};
+use wayland_client::globals::{GlobalList, BindError};
 use std::collections::HashMap;
-use std::sync::{Arc, Mutex};
+use std::sync::Mutex;
+use wayland_client::backend::ObjectId;
 use wayland_client::protocol::wl_output::Transform;
-use wayland_client::protocol::wl_registry::WlRegistry;
-use wayland_client::{Attached, DispatchData, Main};
-use wayland_protocols::wlr::unstable::output_management::v1::client::zwlr_output_head_v1::{
-    Event as ZwlrOutputHeadEvent, ZwlrOutputHeadV1,
-};
-use wayland_protocols::wlr::unstable::output_management::v1::client::zwlr_output_manager_v1::{
-    Event as ZwlrOutputEvent, ZwlrOutputManagerV1,
-};
-use wayland_protocols::wlr::unstable::output_management::v1::client::zwlr_output_mode_v1::{
-    Event as ZwlrOutputModeEvent, ZwlrOutputModeV1,
-};
+
+use super::state::WaylandState;
 
 #[derive(Debug, Default, Clone)]
 pub struct ModeInfo {
-    pub id: u32,
+    pub id: Option<ObjectId>,
     pub width: i32,
     pub height: i32,
     pub refresh: i32,
@@ -30,15 +26,15 @@ pub struct ModeInfo {
 
 #[derive(Debug, Default, Clone)]
 pub struct HeadInfo {
-    pub id: u32,
+    pub id: Option<ObjectId>,
     pub name: String,
     pub description: String,
     pub physical_width: i32,
     pub physical_height: i32,
     /// List of ids that correspond to ModeInfo's
-    pub mode_ids: Vec<u32>,
+    pub mode_ids: Vec<ObjectId>,
     pub enabled: bool,
-    pub current_mode_id: Option<u32>,
+    pub current_mode_id: Option<ObjectId>,
     pub x: i32,
     pub y: i32,
     pub transform: Option<Transform>,
@@ -50,155 +46,27 @@ pub struct HeadInfo {
 
 #[derive(Default, Debug)]
 struct Inner {
-    zwlr_heads: HashMap<u32, Attached<ZwlrOutputHeadV1>>,
-    zwlr_modes: HashMap<u32, Attached<ZwlrOutputModeV1>>,
-    zwlr_mode_info: HashMap<u32, ModeInfo>,
-    zwlr_head_info: HashMap<u32, HeadInfo>,
-}
-
-impl Inner {
-    fn handle_zwlr_mode_event(
-        &mut self,
-        mode: Main<ZwlrOutputModeV1>,
-        event: ZwlrOutputModeEvent,
-        _ddata: DispatchData,
-        _inner: &Arc<Mutex<Self>>,
-    ) {
-        log::debug!("handle_zwlr_mode_event {event:?}");
-        let id = wl_id(mode.detach());
-        let info = self.zwlr_mode_info.entry(id).or_insert_with(|| ModeInfo {
-            id,
-            ..ModeInfo::default()
-        });
-
-        match event {
-            ZwlrOutputModeEvent::Size { width, height } => {
-                info.width = width;
-                info.height = height;
-            }
-            ZwlrOutputModeEvent::Refresh { refresh } => {
-                info.refresh = refresh;
-            }
-            ZwlrOutputModeEvent::Preferred => {
-                info.preferred = true;
-            }
-            ZwlrOutputModeEvent::Finished => {
-                self.zwlr_mode_info.remove(&id);
-                self.zwlr_modes.remove(&id);
-            }
-            _ => {}
-        }
-    }
-
-    fn handle_zwlr_head_event(
-        &mut self,
-        head: Main<ZwlrOutputHeadV1>,
-        event: ZwlrOutputHeadEvent,
-        _ddata: DispatchData,
-        inner: &Arc<Mutex<Self>>,
-    ) {
-        log::debug!("handle_zwlr_head_event {event:?}");
-        let id = wl_id(head.detach());
-        let info = self.zwlr_head_info.entry(id).or_insert_with(|| HeadInfo {
-            id,
-            ..HeadInfo::default()
-        });
-        match event {
-            ZwlrOutputHeadEvent::Name { name } => {
-                info.name = name;
-            }
-            ZwlrOutputHeadEvent::Description { description } => {
-                info.description = description;
-            }
-            ZwlrOutputHeadEvent::PhysicalSize { width, height } => {
-                info.physical_width = width;
-                info.physical_height = height;
-            }
-            ZwlrOutputHeadEvent::Mode { mode } => {
-                let inner = Arc::clone(inner);
-                mode.quick_assign(move |mode, event, ddata| {
-                    inner
-                        .lock()
-                        .unwrap()
-                        .handle_zwlr_mode_event(mode, event, ddata, &inner);
-                });
-                let mode_id = wl_id(mode.detach());
-                info.mode_ids.push(mode_id);
-                self.zwlr_modes.insert(mode_id, mode.into());
-            }
-            ZwlrOutputHeadEvent::Enabled { enabled } => {
-                info.enabled = enabled != 0;
-            }
-            ZwlrOutputHeadEvent::CurrentMode { mode } => {
-                let mode_id = wl_id(mode);
-                info.current_mode_id.replace(mode_id);
-            }
-            ZwlrOutputHeadEvent::Position { x, y } => {
-                info.x = x;
-                info.y = y;
-            }
-            ZwlrOutputHeadEvent::Transform { transform } => {
-                info.transform.replace(transform);
-            }
-            ZwlrOutputHeadEvent::Scale { scale } => {
-                info.scale = scale;
-            }
-            ZwlrOutputHeadEvent::Make { make } => {
-                info.make = make;
-            }
-            ZwlrOutputHeadEvent::Model { model } => {
-                info.model = model;
-            }
-            ZwlrOutputHeadEvent::SerialNumber { serial_number } => {
-                info.serial_number = serial_number;
-            }
-            ZwlrOutputHeadEvent::Finished => {
-                log::debug!("remove head with id {id}");
-                self.zwlr_heads.remove(&id);
-                self.zwlr_head_info.remove(&id);
-            }
-
-            _ => {}
-        }
-    }
-
-    fn handle_zwlr_output_event(
-        &mut self,
-        _output: Main<ZwlrOutputManagerV1>,
-        event: ZwlrOutputEvent,
-        _ddata: DispatchData,
-        inner: &Arc<Mutex<Self>>,
-    ) {
-        log::debug!("handle_zwlr_output_event {event:?}");
-        match event {
-            ZwlrOutputEvent::Head { head } => {
-                let inner = Arc::clone(inner);
-                head.quick_assign(move |output, event, ddata| {
-                    inner
-                        .lock()
-                        .unwrap()
-                        .handle_zwlr_head_event(output, event, ddata, &inner);
-                });
-                self.zwlr_heads.insert(wl_id(head.detach()), head.into());
-            }
-            ZwlrOutputEvent::Done { serial: _ } => {}
-            ZwlrOutputEvent::Finished => {}
-            _ => {}
-        }
-    }
+    zwlr_heads: HashMap<ObjectId, ZwlrOutputHeadV1>,
+    zwlr_modes: HashMap<ObjectId, ZwlrOutputModeV1>,
+    zwlr_mode_info: HashMap<ObjectId, ModeInfo>,
+    zwlr_head_info: HashMap<ObjectId, HeadInfo>,
 }
 
-pub struct OutputHandler {
-    zwlr: Option<Attached<ZwlrOutputManagerV1>>,
-    inner: Arc<Mutex<Inner>>,
+pub struct OutputManagerState {
+    _zwlr: ZwlrOutputManagerV1,
+    inner: Mutex<Inner>,
 }
 
-impl OutputHandler {
-    pub fn new() -> Self {
-        Self {
-            zwlr: None,
-            inner: Arc::new(Mutex::new(Inner::default())),
-        }
+impl OutputManagerState {
+    pub(super) fn bind(
+        globals: &GlobalList,
+        queue_handle: &wayland_client::QueueHandle<WaylandState>,
+    ) -> Result<Self, BindError> {
+        let _zwlr = globals.bind(queue_handle, 1..=1, GlobalData)?;
+        Ok(Self {
+            _zwlr,
+            inner: Mutex::new(Inner::default()),
+        })
     }
 
     pub fn screens(&self) -> Option<Screens> {
@@ -212,7 +80,7 @@ impl OutputHandler {
 
         for head in inner.zwlr_head_info.values() {
             let name = head.name.clone();
-            let (width, height) = match head.current_mode_id {
+            let (width, height) = match head.current_mode_id.clone() {
                 Some(mode_id) => match inner.zwlr_mode_info.get(&mode_id) {
                     Some(mode) => (mode.width, mode.height),
                     None => continue,
@@ -275,32 +143,149 @@ impl OutputHandler {
     }
 }
 
-impl GlobalHandler<ZwlrOutputManagerV1> for OutputHandler {
-    fn created(
-        &mut self,
-        registry: Attached<WlRegistry>,
-        id: u32,
-        version: u32,
-        _ddata: DispatchData,
+#[derive(Default)]
+pub(super) struct OutputManagerData {}
+
+impl Dispatch<ZwlrOutputManagerV1, GlobalData, WaylandState> for OutputManagerState {
+    fn event(
+        state: &mut WaylandState,
+        _proxy: &ZwlrOutputManagerV1,
+        event: <ZwlrOutputManagerV1 as wayland_client::Proxy>::Event,
+        _data: &GlobalData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
     ) {
-        if !config::configuration().enable_zwlr_output_manager {
-            return;
+        log::debug!("handle_zwlr_output_event {event:?}");
+        let mut inner = state.output_manager.as_mut().unwrap().inner.lock().unwrap();
+
+        match event {
+            ZwlrOutputEvent::Head { head } => {
+                inner.zwlr_heads.insert(head.id(), head);
+            }
+            _ => {}
         }
-        log::debug!("created ZwlrOutputManagerV1 {id} {version}");
-        let zwlr = registry.bind::<ZwlrOutputManagerV1>(2, id);
+    }
 
-        let inner = Arc::clone(&self.inner);
-        zwlr.quick_assign(move |output, event, ddata| {
-            inner
-                .lock()
-                .unwrap()
-                .handle_zwlr_output_event(output, event, ddata, &inner);
-        });
+    event_created_child!(WaylandState, ZwlrOutputManagerV1, [
+        zwlr_output_manager_v1::EVT_HEAD_OPCODE => (ZwlrOutputHeadV1, OutputManagerData::default())
+    ]);
+}
+
+impl Dispatch<ZwlrOutputHeadV1, OutputManagerData, WaylandState> for OutputManagerState {
+    fn event(
+        state: &mut WaylandState,
+        head: &ZwlrOutputHeadV1,
+        event: <ZwlrOutputHeadV1 as wayland_client::Proxy>::Event,
+        _data: &OutputManagerData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        log::debug!("handle_zwlr_head_event {event:?}");
+
+        let mut inner = state.output_manager.as_mut().unwrap().inner.lock().unwrap();
+        let id = head.id();
+        let info = inner
+            .zwlr_head_info
+            .entry(id.clone())
+            .or_insert_with(|| HeadInfo {
+                id: Some(id.clone()),
+                ..HeadInfo::default()
+            });
 
-        self.zwlr.replace(zwlr.into());
+        match event {
+            ZwlrOutputHeadEvent::Name { name } => {
+                info.name = name;
+            }
+            ZwlrOutputHeadEvent::Description { description } => {
+                info.description = description;
+            }
+            ZwlrOutputHeadEvent::PhysicalSize { width, height } => {
+                info.physical_width = width;
+                info.physical_height = height;
+            }
+            ZwlrOutputHeadEvent::Mode { mode } => {
+                let mode_id = mode.id();
+                info.mode_ids.push(mode_id.clone().into());
+                inner.zwlr_modes.insert(mode_id, mode.into());
+            }
+            ZwlrOutputHeadEvent::Enabled { enabled } => {
+                info.enabled = enabled != 0;
+            }
+            ZwlrOutputHeadEvent::CurrentMode { mode } => {
+                let mode_id = mode.id();
+                info.current_mode_id.replace(mode_id);
+            }
+            ZwlrOutputHeadEvent::Position { x, y } => {
+                info.x = x;
+                info.y = y;
+            }
+            ZwlrOutputHeadEvent::Transform { transform } => {
+                info.transform = transform.into_result().ok();
+            }
+            ZwlrOutputHeadEvent::Scale { scale } => {
+                info.scale = scale;
+            }
+            ZwlrOutputHeadEvent::Make { make } => {
+                info.make = make;
+            }
+            ZwlrOutputHeadEvent::Model { model } => {
+                info.model = model;
+            }
+            ZwlrOutputHeadEvent::SerialNumber { serial_number } => {
+                info.serial_number = serial_number;
+            }
+            ZwlrOutputHeadEvent::Finished => {
+                log::debug!("remove head with id {id}");
+                inner.zwlr_heads.remove(&id);
+                inner.zwlr_head_info.remove(&id);
+            }
+            _ => {}
+        }
     }
 
-    fn get(&self) -> std::option::Option<Attached<ZwlrOutputManagerV1>> {
-        self.zwlr.clone()
+    event_created_child!(WaylandState, ZwlrOutputModeV1, [
+       zwlr_output_head_v1::EVT_CURRENT_MODE_OPCODE => (ZwlrOutputModeV1, OutputManagerData::default()),
+       zwlr_output_head_v1::EVT_MODE_OPCODE => (ZwlrOutputModeV1, OutputManagerData::default()),
+    ]);
+}
+
+impl Dispatch<ZwlrOutputModeV1, OutputManagerData, WaylandState> for OutputManagerState {
+    fn event(
+        state: &mut WaylandState,
+        mode: &ZwlrOutputModeV1,
+        event: <ZwlrOutputModeV1 as wayland_client::Proxy>::Event,
+        _data: &OutputManagerData,
+        _conn: &wayland_client::Connection,
+        _qhandle: &wayland_client::QueueHandle<WaylandState>,
+    ) {
+        log::debug!("handle_zwlr_mode_event {event:?}");
+        let mut inner = state.output_manager.as_mut().unwrap().inner.lock().unwrap();
+
+        let id = mode.id();
+        let info = inner
+            .zwlr_mode_info
+            .entry(id.clone())
+            .or_insert_with(|| ModeInfo {
+                id: Some(id.clone()),
+                ..ModeInfo::default()
+            });
+
+        match event {
+            ZwlrOutputModeEvent::Size { width, height } => {
+                info.width = width;
+                info.height = height;
+            }
+            ZwlrOutputModeEvent::Refresh { refresh } => {
+                info.refresh = refresh;
+            }
+            ZwlrOutputModeEvent::Preferred => {
+                info.preferred = true;
+            }
+            ZwlrOutputModeEvent::Finished => {
+                inner.zwlr_mode_info.remove(&id);
+                inner.zwlr_modes.remove(&id);
+            }
+            _ => {}
+        }
     }
 }
diff --git a/window/src/os/wayland/pointer.rs b/window/src/os/wayland/pointer.rs
index c9458ce3f38..faefdce89f3 100644
--- a/window/src/os/wayland/pointer.rs
+++ b/window/src/os/wayland/pointer.rs
@@ -1,123 +1,97 @@
-use super::copy_and_paste::*;
-use super::drag_and_drop::*;
-use crate::os::wayland::connection::WaylandConnection;
-use crate::ConnectionOps;
-use smithay_client_toolkit as toolkit;
-use std::collections::HashMap;
+use std::cell::RefCell;
 use std::sync::{Arc, Mutex};
-use toolkit::primary_selection::{PrimarySelectionDevice, PrimarySelectionDeviceManager};
-use toolkit::reexports::client::protocol::wl_data_device::{
-    Event as DataDeviceEvent, WlDataDevice,
+
+use smithay_client_toolkit::compositor::SurfaceData;
+use smithay_client_toolkit::seat::pointer::{
+    PointerData, PointerDataExt, PointerEvent, PointerEventKind, PointerHandler,
 };
-use toolkit::reexports::client::protocol::wl_data_offer::{Event as DataOfferEvent, WlDataOffer};
-use toolkit::reexports::client::protocol::wl_pointer::{Axis, ButtonState, Event as PointerEvent};
-use toolkit::reexports::client::protocol::wl_surface::WlSurface;
-use toolkit::seat::pointer::{ThemeManager, ThemeSpec, ThemedPointer};
-use wayland_client::protocol::wl_compositor::WlCompositor;
-use wayland_client::protocol::wl_data_device_manager::WlDataDeviceManager;
+use smithay_client_toolkit::shell::xdg::frame::{DecorationsFrame, FrameClick};
+use wayland_client::backend::ObjectId;
+use wayland_client::protocol::wl_pointer::{ButtonState, WlPointer};
 use wayland_client::protocol::wl_seat::WlSeat;
-use wayland_client::protocol::wl_shm::WlShm;
-use wayland_client::{Attached, Main};
-use wezterm_input_types::*;
-
-#[derive(Default)]
-struct Inner {
-    active_surface_id: u32,
-    surface_to_pending: HashMap<u32, Arc<Mutex<PendingMouse>>>,
-    drag_and_drop: DragAndDrop,
-    serial: u32,
-}
-
-impl Inner {
-    fn handle_event(&mut self, evt: PointerEvent) {
-        if let PointerEvent::Enter { surface, .. } = &evt {
-            let surface_id = surface.as_ref().id();
-            // update global active surface id
-            let conn = WaylandConnection::get().unwrap().wayland();
-            *conn.active_surface_id.borrow_mut() = surface_id;
-            // update pointer-specific active surface id
-            self.active_surface_id = surface_id;
-        }
-        if let Some(serial) = event_serial(&evt) {
-            self.serial = serial;
-        }
-        if let Some(pending) = self.surface_to_pending.get(&self.active_surface_id) {
-            let mut pending = pending.lock().unwrap();
-            if pending.queue(evt) {
-                WaylandConnection::with_window_inner(pending.window_id, move |inner| {
-                    inner.dispatch_pending_mouse();
-                    Ok(())
-                });
+use wayland_client::{Connection, Proxy, QueueHandle};
+use wezterm_input_types::MousePress;
+
+use crate::wayland::SurfaceUserData;
+
+use super::copy_and_paste::CopyAndPaste;
+use super::drag_and_drop::DragAndDrop;
+use super::state::WaylandState;
+use super::WaylandConnection;
+
+impl PointerHandler for WaylandState {
+    fn pointer_frame(
+        &mut self,
+        _conn: &Connection,
+        _qh: &QueueHandle<Self>,
+        pointer: &WlPointer,
+        events: &[PointerEvent],
+    ) {
+        let mut pstate = pointer
+            .data::<PointerUserData>()
+            .unwrap()
+            .state
+            .lock()
+            .unwrap();
+
+        for evt in events {
+            if let PointerEventKind::Enter { .. } = &evt.kind {
+                let surface_id = evt.surface.id();
+                self.active_surface_id = RefCell::new(Some(surface_id.clone()));
+                pstate.active_surface_id = Some(surface_id);
+            }
+            if let Some(serial) = event_serial(&evt) {
+                *self.last_serial.borrow_mut() = serial;
+                pstate.serial = serial;
+            }
+            if let Some(pending) = self
+                .surface_to_pending
+                .get(&self.active_surface_id.borrow().as_ref().unwrap())
+            {
+                let mut pending = pending.lock().unwrap();
+                if pending.queue(evt) {
+                    WaylandConnection::with_window_inner(pending.window_id, move |inner| {
+                        inner.dispatch_pending_mouse();
+                        Ok(())
+                    });
+                }
             }
         }
+        self.pointer_window_frame(pointer, events);
     }
+}
 
-    fn resolve_copy_and_paste(&mut self) -> Option<Arc<Mutex<CopyAndPaste>>> {
-        let conn = WaylandConnection::get().unwrap().wayland();
-        let active_surface_id = conn.active_surface_id.borrow();
-        if let Some(pending) = self.surface_to_pending.get(&active_surface_id) {
-            Some(Arc::clone(&pending.lock().unwrap().copy_and_paste))
-        } else {
-            None
-        }
-    }
+pub(super) struct PointerUserData {
+    pub(super) pdata: PointerData,
+    pub(super) state: Mutex<PointerState>,
+}
 
-    fn route_data_offer(&mut self, event: DataOfferEvent, offer: WlDataOffer) {
-        if let Some(copy_and_paste) = self.resolve_copy_and_paste() {
-            copy_and_paste
-                .lock()
-                .unwrap()
-                .handle_data_offer(event, offer);
+impl PointerUserData {
+    pub(super) fn new(seat: WlSeat) -> Self {
+        Self {
+            pdata: PointerData::new(seat),
+            state: Default::default(),
         }
     }
+}
 
-    fn handle_data_event(&mut self, event: DataDeviceEvent, inner: &Arc<Mutex<Self>>) {
-        match event {
-            DataDeviceEvent::DataOffer { id } => {
-                id.quick_assign({
-                    let inner = Arc::clone(inner);
-                    move |offer, event, _dispatch_data| {
-                        let mut inner = inner.lock().unwrap();
-                        inner.route_data_offer(event, offer.detach());
-                    }
-                });
-            }
-
-            DataDeviceEvent::Enter { .. }
-            | DataDeviceEvent::Leave
-            | DataDeviceEvent::Motion { .. }
-            | DataDeviceEvent::Drop => {
-                self.drag_and_drop.handle_data_event(event);
-            }
-
-            DataDeviceEvent::Selection { id } => {
-                if let Some(offer) = id {
-                    if let Some(copy_and_paste) = self.resolve_copy_and_paste() {
-                        copy_and_paste.lock().unwrap().confirm_selection(offer);
-                    }
-                }
-            }
-            _ => {}
-        }
-    }
+#[derive(Default)]
+pub(super) struct PointerState {
+    active_surface_id: Option<ObjectId>,
+    pub(super) drag_and_drop: DragAndDrop,
+    serial: u32,
 }
 
-pub struct PointerDispatcher {
-    inner: Arc<Mutex<Inner>>,
-    dev_mgr: Attached<WlDataDeviceManager>,
-    pub(crate) data_device: Main<WlDataDevice>,
-    selection_manager: Option<PrimarySelectionDeviceManager>,
-    pub(crate) primary_selection_device: Option<PrimarySelectionDevice>,
-    auto_pointer: ThemedPointer,
-    #[allow(dead_code)]
-    themer: ThemeManager,
-    pub(crate) seat: WlSeat,
+impl PointerDataExt for PointerUserData {
+    fn pointer_data(&self) -> &PointerData {
+        &self.pdata
+    }
 }
 
 #[derive(Clone, Debug)]
 pub struct PendingMouse {
     window_id: usize,
-    copy_and_paste: Arc<Mutex<CopyAndPaste>>,
+    pub(super) copy_and_paste: Arc<Mutex<CopyAndPaste>>,
     surface_coords: Option<(f64, f64)>,
     button: Vec<(MousePress, ButtonState)>,
     scroll: Option<(f64, f64)>,
@@ -125,7 +99,10 @@ pub struct PendingMouse {
 }
 
 impl PendingMouse {
-    pub fn create(window_id: usize, copy_and_paste: &Arc<Mutex<CopyAndPaste>>) -> Arc<Mutex<Self>> {
+    pub(super) fn create(
+        window_id: usize,
+        copy_and_paste: &Arc<Mutex<CopyAndPaste>>,
+    ) -> Arc<Mutex<Self>> {
         Arc::new(Mutex::new(Self {
             window_id,
             copy_and_paste: Arc::clone(copy_and_paste),
@@ -136,39 +113,24 @@ impl PendingMouse {
         }))
     }
 
-    // Return true if we need to queue up a call to act on the event,
-    // false if we think there is already a pending event
-    pub fn queue(&mut self, evt: PointerEvent) -> bool {
-        match evt {
-            PointerEvent::Enter { serial, .. } => {
-                let conn = WaylandConnection::get().unwrap().wayland();
-                *conn.last_serial.borrow_mut() = serial;
+    pub(super) fn queue(&mut self, evt: &PointerEvent) -> bool {
+        match evt.kind {
+            PointerEventKind::Enter { .. } => {
                 self.in_window = true;
                 false
             }
-            PointerEvent::Leave { .. } => {
+            PointerEventKind::Leave { .. } => {
                 let changed = self.in_window;
                 self.surface_coords = None;
                 self.in_window = false;
                 changed
             }
-            PointerEvent::Motion {
-                surface_x,
-                surface_y,
-                ..
-            } => {
+            PointerEventKind::Motion { .. } => {
                 let changed = self.surface_coords.is_none();
-                self.surface_coords.replace((surface_x, surface_y));
+                self.surface_coords.replace(evt.position);
                 changed
             }
-            PointerEvent::Button {
-                button,
-                state,
-                serial,
-                ..
-            } => {
-                let conn = WaylandConnection::get().unwrap().wayland();
-                *conn.last_serial.borrow_mut() = serial;
+            PointerEventKind::Press { button, .. } | PointerEventKind::Release { button, .. } => {
                 fn linux_button(b: u32) -> Option<MousePress> {
                     // See BTN_LEFT and friends in <linux/input-event-codes.h>
                     match b {
@@ -183,34 +145,29 @@ impl PendingMouse {
                     None => return false,
                 };
                 let changed = self.button.is_empty();
-                self.button.push((button, state));
-                changed
-            }
-            PointerEvent::Axis {
-                axis: Axis::VerticalScroll,
-                value,
-                ..
-            } => {
-                let changed = self.scroll.is_none();
-                let (x, y) = self.scroll.take().unwrap_or((0., 0.));
-                self.scroll.replace((x, y + value));
+                let button_state = match evt.kind {
+                    PointerEventKind::Press { .. } => ButtonState::Pressed,
+                    PointerEventKind::Release { .. } => ButtonState::Released,
+                    _ => unreachable!(),
+                };
+                self.button.push((button, button_state));
                 changed
             }
-            PointerEvent::Axis {
-                axis: Axis::HorizontalScroll,
-                value,
+            PointerEventKind::Axis {
+                horizontal,
+                vertical,
                 ..
             } => {
                 let changed = self.scroll.is_none();
                 let (x, y) = self.scroll.take().unwrap_or((0., 0.));
-                self.scroll.replace((x + value, y));
+                self.scroll
+                    .replace((x + horizontal.absolute, y + vertical.absolute));
                 changed
             }
-            _ => false,
         }
     }
 
-    pub fn next_button(pending: &Arc<Mutex<Self>>) -> Option<(MousePress, ButtonState)> {
+    pub(super) fn next_button(pending: &Arc<Mutex<Self>>) -> Option<(MousePress, ButtonState)> {
         let mut pending = pending.lock().unwrap();
         if pending.button.is_empty() {
             None
@@ -219,149 +176,77 @@ impl PendingMouse {
         }
     }
 
-    pub fn coords(pending: &Arc<Mutex<Self>>) -> Option<(f64, f64)> {
+    pub(super) fn coords(pending: &Arc<Mutex<Self>>) -> Option<(f64, f64)> {
         pending.lock().unwrap().surface_coords.take()
     }
 
-    pub fn scroll(pending: &Arc<Mutex<Self>>) -> Option<(f64, f64)> {
+    pub(super) fn scroll(pending: &Arc<Mutex<Self>>) -> Option<(f64, f64)> {
         pending.lock().unwrap().scroll.take()
     }
 
-    pub fn in_window(pending: &Arc<Mutex<Self>>) -> bool {
+    pub(super) fn in_window(pending: &Arc<Mutex<Self>>) -> bool {
         pending.lock().unwrap().in_window
     }
 }
 
-pub fn make_theme_manager(
-    compositor: Attached<WlCompositor>,
-    shm: Attached<WlShm>,
-) -> ThemeManager {
-    let config = config::configuration();
-    let name = config
-        .xcursor_theme
-        .as_ref()
-        .map(|s| s.to_string())
-        .or_else(|| std::env::var("XCURSOR_THEME").ok())
-        .unwrap_or_else(|| "default".to_string());
-    let size = match config.xcursor_size {
-        Some(size) => size,
-        None => match std::env::var("XCURSOR_SIZE").ok() {
-            Some(size_str) => size_str.parse().ok(),
-            None => None,
-        }
-        .unwrap_or(24),
-    };
-
-    let theme = ThemeSpec::Precise { name: &name, size };
-
-    ThemeManager::init(theme, compositor, shm)
+fn event_serial(event: &PointerEvent) -> Option<u32> {
+    Some(match event.kind {
+        PointerEventKind::Enter { serial, .. } => serial,
+        PointerEventKind::Leave { serial, .. } => serial,
+        PointerEventKind::Press { serial, .. } => serial,
+        PointerEventKind::Release { serial, .. } => serial,
+        _ => return None,
+    })
 }
 
-impl PointerDispatcher {
-    pub fn register(
-        seat: &WlSeat,
-        compositor: Attached<WlCompositor>,
-        shm: Attached<WlShm>,
-        dev_mgr: Attached<WlDataDeviceManager>,
-        selection_manager: Option<PrimarySelectionDeviceManager>,
-    ) -> anyhow::Result<Self> {
-        let inner = Arc::new(Mutex::new(Inner::default()));
-        let pointer = seat.get_pointer();
-        pointer.quick_assign({
-            let inner = Arc::clone(&inner);
-            move |_, evt, _| {
-                inner.lock().unwrap().handle_event(evt);
-            }
-        });
-
-        let themer = make_theme_manager(compositor, shm);
-        let auto_pointer = themer.theme_pointer(pointer.detach());
-
-        let data_device = dev_mgr.get_data_device(seat);
-        data_device.quick_assign({
-            let inner = Arc::clone(&inner);
-            move |_device, event, _| {
-                inner.lock().unwrap().handle_data_event(event, &inner);
-            }
-        });
-
-        let primary_selection_device = selection_manager
-            .as_ref()
-            .map(|m| PrimarySelectionDevice::init_for_seat(&m, seat));
-
-        Ok(Self {
-            inner,
-            dev_mgr,
-            data_device,
-            selection_manager,
-            primary_selection_device,
-            themer,
-            auto_pointer,
-            seat: seat.clone(),
-        })
-    }
-
-    pub fn seat_changed(&mut self, seat: &WlSeat) {
-        let inner = Arc::clone(&self.inner);
-
-        let pointer = seat.get_pointer();
-        pointer.quick_assign({
-            let inner = Arc::clone(&inner);
-            move |_, evt, _| {
-                inner.lock().unwrap().handle_event(evt);
-            }
-        });
-        let data_device = self.dev_mgr.get_data_device(seat);
-        data_device.quick_assign({
-            let inner = Arc::clone(&inner);
-            move |_device, event, _| {
-                inner.lock().unwrap().handle_data_event(event, &inner);
-            }
-        });
-
-        let primary_selection_device = self
-            .selection_manager
-            .as_ref()
-            .map(|m| PrimarySelectionDevice::init_for_seat(&m, seat));
-
-        self.data_device = data_device;
-        self.primary_selection_device = primary_selection_device;
-        self.seat = seat.clone();
-    }
+impl WaylandState {
+    fn pointer_window_frame(&mut self, pointer: &WlPointer, events: &[PointerEvent]) {
+        let windows = self.windows.borrow();
+
+        for evt in events {
+            let surface = &evt.surface;
+            if surface.id() == self.active_surface_id.borrow().as_ref().unwrap().clone() {
+                let (x, y) = evt.position;
+                let parent_surface = match evt.surface.data::<SurfaceData>() {
+                    Some(data) => match data.parent_surface() {
+                        Some(sd) => sd,
+                        None => continue,
+                    },
+                    None => continue,
+                };
 
-    pub fn add_window(&self, surface: &WlSurface, pending: &Arc<Mutex<PendingMouse>>) {
-        let mut inner = self.inner.lock().unwrap();
-        inner
-            .surface_to_pending
-            .insert(surface.as_ref().id(), Arc::clone(pending));
-    }
+                let wid = SurfaceUserData::from_wl(parent_surface).window_id;
+                let mut inner = windows.get(&wid).unwrap().borrow_mut();
 
-    pub fn set_cursor(&self, names: &[&str], serial: Option<u32>) {
-        if names.is_empty() {
-            (*self.auto_pointer).set_cursor(0, None, 0, 0);
-        } else {
-            let mut errors = vec![];
-            for name in names {
-                match self.auto_pointer.set_cursor(name, serial) {
-                    Ok(_) => return,
-                    Err(err) => errors.push(format!("Unable to set cursor to {name}: {err:#}")),
+                match evt.kind {
+                    PointerEventKind::Enter { .. } => {
+                        inner.window_frame.click_point_moved(&evt.surface, x, y);
+                    }
+                    PointerEventKind::Leave { .. } => {
+                        inner.window_frame.click_point_left();
+                    }
+                    PointerEventKind::Motion { .. } => {
+                        inner.window_frame.click_point_moved(&evt.surface, x, y);
+                    }
+                    PointerEventKind::Press { button, serial, .. }
+                    | PointerEventKind::Release { button, serial, .. } => {
+                        let pressed = if matches!(evt.kind, PointerEventKind::Press { .. }) {
+                            true
+                        } else {
+                            false
+                        };
+                        let click = match button {
+                            0x110 => FrameClick::Normal,
+                            0x111 => FrameClick::Alternate,
+                            _ => continue,
+                        };
+                        if let Some(action) = inner.window_frame.on_click(click, pressed) {
+                            inner.frame_action(pointer, serial, action);
+                        }
+                    }
+                    _ => {}
                 }
             }
-
-            if let Err(err) = self.auto_pointer.set_cursor("default", serial) {
-                errors.push(format!("Unable to set cursor to 'default': {err:#}"));
-            }
-
-            log::error!("set_cursor: {}", errors.join(", "));
         }
     }
 }
-
-fn event_serial(event: &PointerEvent) -> Option<u32> {
-    Some(*match event {
-        PointerEvent::Enter { serial, .. } => serial,
-        PointerEvent::Leave { serial, .. } => serial,
-        PointerEvent::Button { serial, .. } => serial,
-        _ => return None,
-    })
-}
diff --git a/window/src/os/wayland/seat.rs b/window/src/os/wayland/seat.rs
new file mode 100644
index 00000000000..3798f4259e5
--- /dev/null
+++ b/window/src/os/wayland/seat.rs
@@ -0,0 +1,76 @@
+use smithay_client_toolkit::seat::pointer::ThemeSpec;
+use smithay_client_toolkit::seat::{Capability, SeatHandler, SeatState};
+use wayland_client::protocol::wl_seat::WlSeat;
+use wayland_client::{Connection, QueueHandle};
+
+use crate::wayland::copy_and_paste::PrimarySelectionManagerData;
+use crate::wayland::keyboard::KeyboardData;
+use crate::wayland::pointer::PointerUserData;
+
+use super::state::WaylandState;
+
+impl SeatHandler for WaylandState {
+    fn seat_state(&mut self) -> &mut SeatState {
+        &mut self.seat
+    }
+
+    fn new_seat(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _seat: WlSeat) {
+        todo!()
+    }
+
+    fn new_capability(
+        &mut self,
+        _conn: &Connection,
+        qh: &QueueHandle<Self>,
+        seat: WlSeat,
+        capability: smithay_client_toolkit::seat::Capability,
+    ) {
+        if capability == Capability::Keyboard && self.keyboard.is_none() {
+            log::trace!("Setting keyboard capability");
+            let keyboard = seat.get_keyboard(qh, KeyboardData {});
+            self.keyboard = Some(keyboard.clone());
+
+            if let Some(text_input) = &self.text_input {
+                text_input.advise_seat(&seat, &keyboard, qh);
+            }
+        }
+
+        if capability == Capability::Pointer && self.pointer.is_none() {
+            log::trace!("Setting pointer capability");
+            let pointer = self
+                .seat
+                .get_pointer_with_theme_and_data(
+                    qh,
+                    &seat,
+                    ThemeSpec::System,
+                    PointerUserData::new(seat.clone()),
+                )
+                .expect("Failed to create pointer");
+            self.pointer = Some(pointer);
+
+            let data_device_manager = &self.data_device_manager_state;
+            let data_device = data_device_manager.get_data_device(qh, &seat);
+            self.data_device.replace(data_device);
+
+            let primary_select_device = self.primary_selection_manager.as_ref().map(|m| {
+                m.manager
+                    .get_device(&seat, qh, PrimarySelectionManagerData::default())
+            });
+            self.primary_select_device = primary_select_device;
+        }
+    }
+
+    fn remove_capability(
+        &mut self,
+        _conn: &Connection,
+        _qh: &QueueHandle<Self>,
+        _seat: WlSeat,
+        _capability: smithay_client_toolkit::seat::Capability,
+    ) {
+        todo!()
+    }
+
+    fn remove_seat(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _seat: WlSeat) {
+        todo!()
+    }
+}
diff --git a/window/src/os/wayland/state.rs b/window/src/os/wayland/state.rs
new file mode 100644
index 00000000000..c410e681766
--- /dev/null
+++ b/window/src/os/wayland/state.rs
@@ -0,0 +1,192 @@
+use std::cell::RefCell;
+use std::collections::HashMap;
+use std::rc::Rc;
+use std::sync::{Arc, Mutex};
+
+use smithay_client_toolkit::compositor::CompositorState;
+use smithay_client_toolkit::data_device_manager::data_device::DataDevice;
+use smithay_client_toolkit::data_device_manager::data_source::CopyPasteSource;
+use smithay_client_toolkit::data_device_manager::DataDeviceManagerState;
+use smithay_client_toolkit::globals::GlobalData;
+use smithay_client_toolkit::output::{OutputHandler, OutputState};
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_head_v1::ZwlrOutputHeadV1;
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_manager_v1::ZwlrOutputManagerV1;
+use smithay_client_toolkit::reexports::protocols_wlr::output_management::v1::client::zwlr_output_mode_v1::ZwlrOutputModeV1;
+use smithay_client_toolkit::registry::{ProvidesRegistryState, RegistryState};
+use smithay_client_toolkit::seat::pointer::ThemedPointer;
+use smithay_client_toolkit::seat::SeatState;
+use smithay_client_toolkit::shell::xdg::XdgShell;
+use smithay_client_toolkit::shm::slot::SlotPool;
+use smithay_client_toolkit::shm::{Shm, ShmHandler};
+use smithay_client_toolkit::subcompositor::SubcompositorState;
+use smithay_client_toolkit::{
+    delegate_compositor, delegate_data_device, delegate_data_device_manager, delegate_data_offer, delegate_data_source, delegate_output, delegate_registry, delegate_seat, delegate_shm, delegate_subcompositor, delegate_xdg_shell, delegate_xdg_window, registry_handlers
+};
+use wayland_client::backend::ObjectId;
+use wayland_client::globals::GlobalList;
+use wayland_client::protocol::wl_keyboard::WlKeyboard;
+use wayland_client::protocol::wl_output::WlOutput;
+use wayland_client::protocol::wl_pointer::WlPointer;
+use wayland_client::protocol::wl_surface::WlSurface;
+use wayland_client::{delegate_dispatch, Connection, QueueHandle};
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_device_manager_v1::ZwpPrimarySelectionDeviceManagerV1;
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_device_v1::ZwpPrimarySelectionDeviceV1;
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_offer_v1::ZwpPrimarySelectionOfferV1;
+use wayland_protocols::wp::primary_selection::zv1::client::zwp_primary_selection_source_v1::ZwpPrimarySelectionSourceV1;
+use wayland_protocols::wp::text_input::zv3::client::zwp_text_input_manager_v3::ZwpTextInputManagerV3;
+use wayland_protocols::wp::text_input::zv3::client::zwp_text_input_v3::ZwpTextInputV3;
+
+use crate::x11::KeyboardWithFallback;
+
+use super::copy_and_paste::{PrimarySelectionManagerData, PrimarySelectionManagerState};
+use super::inputhandler::{TextInputData, TextInputState};
+use super::pointer::{PendingMouse, PointerUserData};
+use super::{OutputManagerData, OutputManagerState, SurfaceUserData, WaylandWindowInner};
+
+// We can't combine WaylandState and WaylandConnection together because
+// the run_message_loop has &self(WaylandConnection) and needs to update WaylandState as mut
+pub(super) struct WaylandState {
+    registry: RegistryState,
+    pub(super) output: OutputState,
+    pub(super) compositor: CompositorState,
+    pub(super) subcompositor: Arc<SubcompositorState>,
+    pub(super) text_input: Option<TextInputState>,
+    pub(super) output_manager: Option<OutputManagerState>,
+    pub(super) seat: SeatState,
+    pub(super) xdg: XdgShell,
+    pub(super) windows: RefCell<HashMap<usize, Rc<RefCell<WaylandWindowInner>>>>,
+
+    pub(super) active_surface_id: RefCell<Option<ObjectId>>,
+    pub(super) last_serial: RefCell<u32>,
+    pub(super) keyboard: Option<WlKeyboard>,
+    pub(super) keyboard_mapper: Option<KeyboardWithFallback>,
+    pub(super) key_repeat_delay: i32,
+    pub(super) key_repeat_rate: i32,
+    pub(super) keyboard_window_id: Option<usize>,
+
+    pub(super) pointer: Option<ThemedPointer<PointerUserData>>,
+    pub(super) surface_to_pending: HashMap<ObjectId, Arc<Mutex<PendingMouse>>>,
+
+    pub(super) data_device_manager_state: DataDeviceManagerState,
+    pub(super) data_device: Option<DataDevice>,
+    pub(super) copy_paste_source: Option<(CopyPasteSource, String)>,
+    pub(super) primary_selection_manager: Option<PrimarySelectionManagerState>,
+    pub(super) primary_select_device: Option<ZwpPrimarySelectionDeviceV1>,
+    pub(super) primary_selection_source: Option<(ZwpPrimarySelectionSourceV1, String)>,
+    pub(super) shm: Shm,
+    pub(super) mem_pool: RefCell<SlotPool>,
+}
+
+impl WaylandState {
+    pub(super) fn new(globals: &GlobalList, qh: &QueueHandle<Self>) -> anyhow::Result<Self> {
+        let shm = Shm::bind(&globals, qh)?;
+        let mem_pool = SlotPool::new(1, &shm)?;
+
+        let compositor = CompositorState::bind(globals, qh)?;
+        let subcompositor =
+            SubcompositorState::bind(compositor.wl_compositor().clone(), globals, qh)?;
+
+        let wayland_state = WaylandState {
+            registry: RegistryState::new(globals),
+            output: OutputState::new(globals, qh),
+            compositor,
+            subcompositor: Arc::new(subcompositor),
+            text_input: TextInputState::bind(globals, qh).ok(),
+            output_manager: if config::configuration().enable_zwlr_output_manager {
+                Some(OutputManagerState::bind(globals, qh)?)
+            } else {
+                None
+            },
+            windows: RefCell::new(HashMap::new()),
+            seat: SeatState::new(globals, qh),
+            xdg: XdgShell::bind(globals, qh)?,
+            active_surface_id: RefCell::new(None),
+            last_serial: RefCell::new(0),
+            keyboard: None,
+            keyboard_mapper: None,
+            key_repeat_rate: 25,
+            key_repeat_delay: 400,
+            keyboard_window_id: None,
+            pointer: None,
+            surface_to_pending: HashMap::new(),
+            data_device_manager_state: DataDeviceManagerState::bind(globals, qh)?,
+            data_device: None,
+            copy_paste_source: None,
+            primary_selection_manager: PrimarySelectionManagerState::bind(globals, qh).ok(),
+            primary_select_device: None,
+            primary_selection_source: None,
+            shm,
+            mem_pool: RefCell::new(mem_pool),
+        };
+        Ok(wayland_state)
+    }
+}
+
+impl ProvidesRegistryState for WaylandState {
+    fn registry(&mut self) -> &mut RegistryState {
+        &mut self.registry
+    }
+
+    registry_handlers![OutputState, SeatState];
+}
+
+impl ShmHandler for WaylandState {
+    fn shm_state(&mut self) -> &mut Shm {
+        &mut self.shm
+    }
+}
+
+impl OutputHandler for WaylandState {
+    fn output_state(&mut self) -> &mut OutputState {
+        &mut self.output
+    }
+
+    fn new_output(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _output: WlOutput) {
+        log::trace!("new output: OutputHandler");
+    }
+
+    fn update_output(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _output: WlOutput) {
+        log::trace!("update output: OutputHandler");
+    }
+
+    fn output_destroyed(&mut self, _conn: &Connection, _qh: &QueueHandle<Self>, _output: WlOutput) {
+        log::trace!("output destroyed: OutputHandler");
+    }
+}
+// Undocumented in sctk 0.17: This is required to use have user data with a surface
+// Will be just delegate_compositor!(WaylandState, surface: [SurfaceData, SurfaceUserData]) in 0.18
+delegate_dispatch!(WaylandState: [ WlSurface: SurfaceUserData] => CompositorState);
+
+delegate_registry!(WaylandState);
+
+delegate_shm!(WaylandState);
+
+delegate_output!(WaylandState);
+delegate_compositor!(WaylandState);
+delegate_subcompositor!(WaylandState);
+
+delegate_seat!(WaylandState);
+
+delegate_data_device_manager!(WaylandState);
+delegate_data_device!(WaylandState);
+delegate_data_source!(WaylandState);
+delegate_data_offer!(WaylandState);
+
+// Updating to 0.18 should have this be able to work
+// delegate_pointer!(WaylandState, pointer: [PointerUserData]);
+delegate_dispatch!(WaylandState: [WlPointer: PointerUserData] => SeatState);
+
+delegate_xdg_shell!(WaylandState);
+delegate_xdg_window!(WaylandState);
+
+delegate_dispatch!(WaylandState: [ZwpTextInputManagerV3: GlobalData] => TextInputState);
+delegate_dispatch!(WaylandState: [ZwpTextInputV3: TextInputData] => TextInputState);
+
+delegate_dispatch!(WaylandState: [ZwlrOutputManagerV1: GlobalData] => OutputManagerState);
+delegate_dispatch!(WaylandState: [ZwlrOutputHeadV1: OutputManagerData] => OutputManagerState);
+delegate_dispatch!(WaylandState: [ZwlrOutputModeV1: OutputManagerData] => OutputManagerState);
+
+delegate_dispatch!(WaylandState: [ZwpPrimarySelectionDeviceManagerV1: GlobalData] => PrimarySelectionManagerState);
+delegate_dispatch!(WaylandState: [ZwpPrimarySelectionDeviceV1: PrimarySelectionManagerData] => PrimarySelectionManagerState);
+delegate_dispatch!(WaylandState: [ZwpPrimarySelectionSourceV1: PrimarySelectionManagerData] => PrimarySelectionManagerState);
+delegate_dispatch!(WaylandState: [ZwpPrimarySelectionOfferV1: PrimarySelectionManagerData] => PrimarySelectionManagerState);
diff --git a/window/src/os/wayland/window.rs b/window/src/os/wayland/window.rs
index 64095e7cdcc..2f77ade8b7b 100644
--- a/window/src/os/wayland/window.rs
+++ b/window/src/os/wayland/window.rs
@@ -1,65 +1,83 @@
-use super::copy_and_paste::*;
-use super::frame::{ConceptConfig, ConceptFrame};
-use super::pointer::*;
-use crate::connection::ConnectionOps;
-use crate::os::wayland::connection::WaylandConnection;
-use crate::os::wayland::wl_id;
-use crate::os::x11::keyboard::KeyboardWithFallback;
-use crate::{
-    Appearance, Clipboard, Connection, Dimensions, MouseCursor, Point, Rect,
-    RequestedWindowGeometry, ResizeIncrement, ResolvedGeometry, ScreenPoint, Window, WindowEvent,
-    WindowEventSender, WindowKeyEvent, WindowOps, WindowState,
-};
-use anyhow::{anyhow, bail, Context};
-use async_io::Timer;
-use async_trait::async_trait;
-use config::ConfigHandle;
-use filedescriptor::FileDescriptor;
-use promise::{Future, Promise};
-use raw_window_handle::{
-    HasRawDisplayHandle, HasRawWindowHandle, RawDisplayHandle, RawWindowHandle,
-    WaylandDisplayHandle, WaylandWindowHandle,
-};
-use smithay_client_toolkit as toolkit;
 use std::any::Any;
-use std::cell::RefCell;
+use std::cell::{RefCell, RefMut};
 use std::cmp::max;
 use std::convert::TryInto;
 use std::io::Read;
+use std::num::NonZeroU32;
 use std::os::unix::io::AsRawFd;
 use std::path::PathBuf;
 use std::rc::Rc;
 use std::sync::{Arc, Mutex};
 use std::time::{Duration, Instant};
-use toolkit::get_surface_scale_factor;
-use toolkit::reexports::client::protocol::wl_pointer::ButtonState;
-use toolkit::reexports::client::protocol::wl_surface::WlSurface;
-use toolkit::window::{Decorations, Event as SCTKWindowEvent, State};
+
+use anyhow::{anyhow, bail};
+use async_io::Timer;
+use async_trait::async_trait;
+use config::ConfigHandle;
+use filedescriptor::FileDescriptor;
+use promise::{Future, Promise};
+use raw_window_handle::{
+    HasRawDisplayHandle, HasRawWindowHandle, RawDisplayHandle, RawWindowHandle,
+    WaylandDisplayHandle, WaylandWindowHandle,
+};
+use smithay_client_toolkit::compositor::{CompositorHandler, SurfaceData, SurfaceDataExt};
+use smithay_client_toolkit::shell::xdg::frame::fallback_frame::FallbackFrame;
+use smithay_client_toolkit::shell::xdg::frame::{DecorationsFrame, FrameAction};
+use smithay_client_toolkit::shell::xdg::window::{
+    DecorationMode, Window as XdgWindow, WindowConfigure, WindowDecorations as Decorations,
+    WindowHandler, WindowState as SCTKWindowState,
+};
+use smithay_client_toolkit::shell::xdg::XdgSurface;
+use smithay_client_toolkit::shell::WaylandSurface;
 use wayland_client::protocol::wl_callback::WlCallback;
 use wayland_client::protocol::wl_keyboard::{Event as WlKeyboardEvent, KeyState};
-use wayland_client::{Attached, Main};
+use wayland_client::protocol::wl_pointer::{ButtonState, WlPointer};
+use wayland_client::protocol::wl_surface::WlSurface;
+use wayland_client::{Connection as WConnection, Proxy};
 use wayland_egl::{is_available as egl_is_available, WlEglSurface};
 use wezterm_font::FontConfiguration;
-use wezterm_input_types::*;
+use wezterm_input_types::{
+    KeyboardLedStatus, Modifiers, MouseButtons, MouseEvent, MouseEventKind, MousePress,
+    ScreenPoint, WindowDecorations,
+};
+
+use super::copy_and_paste::CopyAndPaste;
+use super::pointer::{PendingMouse, PointerUserData};
+use super::state::WaylandState;
+
+use crate::connection::ConnectionOps;
+use crate::os::wayland::connection::WaylandConnection;
+use crate::os::x11::keyboard::KeyboardWithFallback;
+use crate::{
+    Clipboard, Connection, Dimensions, MouseCursor, Point, Rect, RequestedWindowGeometry,
+    ResizeIncrement, ResolvedGeometry, Window, WindowEvent, WindowEventSender, WindowKeyEvent,
+    WindowOps, WindowState,
+};
 
 #[derive(Debug)]
-struct KeyRepeatState {
-    when: Instant,
-    event: WindowKeyEvent,
+pub(super) struct KeyRepeatState {
+    pub(super) when: Instant,
+    pub(super) event: WindowKeyEvent,
 }
 
 impl KeyRepeatState {
-    fn schedule(state: Arc<Mutex<Self>>, window_id: usize) {
+    pub(super) fn schedule(state: Arc<Mutex<Self>>, window_id: usize) {
         promise::spawn::spawn_into_main_thread(async move {
             let delay;
             let gap;
             {
                 let conn = WaylandConnection::get().unwrap().wayland();
-                let rate = *conn.key_repeat_rate.borrow() as u64;
+                let (rate, ddelay) = {
+                    let wstate = conn.wayland_state.borrow();
+                    (
+                        wstate.key_repeat_rate as u64,
+                        wstate.key_repeat_delay as u64,
+                    )
+                };
                 if rate == 0 {
                     return;
                 }
-                delay = Duration::from_millis(*conn.key_repeat_delay.borrow() as u64);
+                delay = Duration::from_millis(ddelay);
                 gap = Duration::from_millis(1000 / rate);
             }
 
@@ -126,111 +144,9 @@ impl KeyRepeatState {
     }
 }
 
-pub struct WaylandWindowInner {
-    window_id: usize,
-    pub(crate) events: WindowEventSender,
-    surface: Attached<WlSurface>,
-    surface_factor: f64,
-    copy_and_paste: Arc<Mutex<CopyAndPaste>>,
-    window: Option<toolkit::window::Window<ConceptFrame>>,
-    dimensions: Dimensions,
-    resize_increments: Option<ResizeIncrement>,
-    window_state: WindowState,
-    last_mouse_coords: Point,
-    mouse_buttons: MouseButtons,
-    hscroll_remainder: f64,
-    vscroll_remainder: f64,
-    modifiers: Modifiers,
-    leds: KeyboardLedStatus,
-    key_repeat: Option<(u32, Arc<Mutex<KeyRepeatState>>)>,
-    pending_event: Arc<Mutex<PendingEvent>>,
-    pending_mouse: Arc<Mutex<PendingMouse>>,
-    pending_first_configure: Option<async_channel::Sender<()>>,
-    frame_callback: Option<Main<WlCallback>>,
-    invalidated: bool,
-    font_config: Rc<FontConfiguration>,
-    text_cursor: Option<Rect>,
-    appearance: Appearance,
-    config: ConfigHandle,
-    // cache the title for comparison to avoid spamming
-    // the compositor with updates that don't actually change it
-    title: Option<String>,
-    // wegl_surface is listed before gl_state because it
-    // must be dropped before gl_state otherwise the underlying
-    // libraries will segfault on shutdown
-    wegl_surface: Option<WlEglSurface>,
-    gl_state: Option<Rc<glium::backend::Context>>,
-}
-
-#[derive(Default, Clone, Debug)]
-struct PendingEvent {
-    close: bool,
-    had_configure_event: bool,
-    refresh_decorations: bool,
-    configure: Option<(u32, u32)>,
-    dpi: Option<i32>,
-    window_state: Option<WindowState>,
-}
-
-impl PendingEvent {
-    fn queue(&mut self, evt: SCTKWindowEvent) -> bool {
-        match evt {
-            SCTKWindowEvent::Close => {
-                if !self.close {
-                    self.close = true;
-                    true
-                } else {
-                    false
-                }
-            }
-            SCTKWindowEvent::Refresh => {
-                if !self.refresh_decorations {
-                    self.refresh_decorations = true;
-                    true
-                } else {
-                    false
-                }
-            }
-            SCTKWindowEvent::Configure { new_size, states } => {
-                let mut changed;
-                self.had_configure_event = true;
-                if let Some(new_size) = new_size {
-                    changed = self.configure.is_none();
-                    self.configure.replace(new_size);
-                } else {
-                    changed = true;
-                }
-                let mut state = WindowState::default();
-                for s in &states {
-                    match s {
-                        State::Fullscreen => {
-                            state |= WindowState::FULL_SCREEN;
-                        }
-                        State::Maximized
-                        | State::TiledLeft
-                        | State::TiledRight
-                        | State::TiledTop
-                        | State::TiledBottom => {
-                            state |= WindowState::MAXIMIZED;
-                        }
-                        _ => {}
-                    }
-                }
-                log::debug!(
-                    "Config: self.window_state={:?}, states:{:?} {:?}",
-                    self.window_state,
-                    state,
-                    states
-                );
-                if self.window_state.is_none() && state != WindowState::default() {
-                    changed = true;
-                }
-                // Always set it to avoid losing non-default -> default transitions
-                self.window_state.replace(state);
-                changed
-            }
-        }
-    }
+enum WaylandWindowEvent {
+    Close,
+    Request(WindowConfigure),
 }
 
 #[derive(Clone, Debug, PartialEq, Eq, Hash, Ord, PartialOrd)]
@@ -242,7 +158,7 @@ impl WaylandWindow {
         name: &str,
         geometry: RequestedWindowGeometry,
         config: Option<&ConfigHandle>,
-        font_config: Rc<FontConfiguration>,
+        _font_config: Rc<FontConfiguration>,
         event_handler: F,
     ) -> anyhow::Result<Window>
     where
@@ -252,11 +168,12 @@ impl WaylandWindow {
             Some(c) => c.clone(),
             None => config::configuration(),
         };
+
         let conn = WaylandConnection::get()
             .ok_or_else(|| {
                 anyhow!(
-                "new_window must be called on the gui thread after Connection::init has succeeded",
-            )
+                    "new_window must be called on the gui thread after Connection:init has succeed",
+                )
             })?
             .wayland();
 
@@ -265,24 +182,22 @@ impl WaylandWindow {
 
         let (pending_first_configure, wait_configure) = async_channel::bounded(1);
 
-        let surface = conn.environment.create_surface_with_scale_callback({
-            let pending_event = Arc::clone(&pending_event);
-            move |dpi, surface, _dispatch_data| {
-                pending_event.lock().unwrap().dpi.replace(dpi);
-                log::debug!(
-                    "surface id={} dpi scale changed to {}",
-                    surface.as_ref().id(),
-                    dpi
-                );
-                WaylandConnection::with_window_inner(window_id, move |inner| {
-                    inner.dispatch_pending_event();
-                    Ok(())
-                });
-            }
-        });
-        conn.surface_to_window_id
-            .borrow_mut()
-            .insert(surface.as_ref().id(), window_id);
+        let qh = conn.event_queue.borrow().handle();
+
+        // We need user data so we can get the window_id => WaylandWindowInner during a handler
+        let surface_data = SurfaceUserData {
+            surface_data: SurfaceData::default(),
+            window_id,
+        };
+        let surface = {
+            let compositor = &conn.wayland_state.borrow().compositor;
+            compositor.create_surface_with_data(&qh, surface_data)
+        };
+
+        let pointer_surface = {
+            let compositor = &conn.wayland_state.borrow().compositor;
+            compositor.create_surface(&qh)
+        };
 
         let ResolvedGeometry {
             x: _,
@@ -297,70 +212,71 @@ impl WaylandWindow {
             dpi: config.dpi.unwrap_or(crate::DEFAULT_DPI) as usize,
         };
 
-        let theme_manager = None;
-
-        let mut window = conn
-            .environment
-            .create_window::<ConceptFrame, _>(
-                surface.clone().detach(),
-                theme_manager,
-                (
-                    dimensions.pixel_width as u32,
-                    dimensions.pixel_height as u32,
-                ),
-                {
-                    let pending_event = Arc::clone(&pending_event);
-                    move |evt, mut _dispatch_data| {
-                        if pending_event.lock().unwrap().queue(evt) {
-                            WaylandConnection::with_window_inner(window_id, move |inner| {
-                                inner.dispatch_pending_event();
-                                Ok(())
-                            });
-                        }
-                    }
-                },
-            )
-            .context("Failed to create window")?;
+        let window = {
+            let xdg_shell = &conn.wayland_state.borrow().xdg;
+            xdg_shell.create_window(surface.clone(), Decorations::RequestServer, &qh)
+        };
 
         window.set_app_id(class_name.to_string());
-        window.set_resizable(true);
         window.set_title(name.to_string());
         let decorations = config.window_decorations;
 
-        window.set_decorate(if decorations == WindowDecorations::NONE {
-            Decorations::None
+        let decor_mode = if decorations == WindowDecorations::NONE {
+            None
         } else if decorations == WindowDecorations::default() {
-            Decorations::FollowServer
+            Some(DecorationMode::Server)
         } else {
-            // SCTK/Wayland don't allow more nuance than "decorations are hidden",
-            // so if we have a mixture of things, then we need to force our
-            // client side decoration rendering.
-            Decorations::ClientSide
-        });
-
-        window.set_frame_config(ConceptConfig {
-            font_config: Some(Rc::clone(&font_config)),
-            config: config.clone(),
-        });
+            Some(DecorationMode::Client)
+        };
+        window.request_decoration_mode(decor_mode);
+
+        let mut window_frame = {
+            let wayland_state = &conn.wayland_state.borrow();
+            let shm = &wayland_state.shm;
+            let subcompositor = wayland_state.subcompositor.clone();
+            FallbackFrame::new(&window, shm, subcompositor, qh.clone())
+                .expect("failed to create csd frame")
+        };
+        let hidden = if let Some(decor) = decor_mode {
+            match decor {
+                DecorationMode::Client => false,
+                _ => true,
+            }
+        } else {
+            true
+        };
+        window_frame.set_hidden(hidden);
+        window_frame.resize(
+            NonZeroU32::new(dimensions.pixel_width as u32).unwrap(),
+            NonZeroU32::new(dimensions.pixel_height as u32).unwrap(),
+        );
 
         window.set_min_size(Some((32, 32)));
+        let (w, h) = window_frame.add_borders(
+            dimensions.pixel_width as u32,
+            dimensions.pixel_height as u32,
+        );
+        let (x, y) = window_frame.location();
+        window
+            .xdg_surface()
+            .set_window_geometry(x, y, w as i32, h as i32);
+        window.commit();
 
         let copy_and_paste = CopyAndPaste::create();
         let pending_mouse = PendingMouse::create(window_id, &copy_and_paste);
 
-        conn.pointer.borrow().add_window(&surface, &pending_mouse);
+        {
+            let surface_to_pending = &mut conn.wayland_state.borrow_mut().surface_to_pending;
+            surface_to_pending.insert(surface.id(), Arc::clone(&pending_mouse));
+        }
 
         let inner = Rc::new(RefCell::new(WaylandWindowInner {
-            window_id,
-            font_config,
-            config,
-            key_repeat: None,
-            copy_and_paste,
             events: WindowEventSender::new(event_handler),
-            surface,
             surface_factor: 1.0,
+            copy_and_paste,
             invalidated: false,
             window: Some(window),
+            window_frame,
             dimensions,
             resize_increments: None,
             window_state: WindowState::default(),
@@ -368,26 +284,39 @@ impl WaylandWindow {
             mouse_buttons: MouseButtons::NONE,
             hscroll_remainder: 0.0,
             vscroll_remainder: 0.0,
+
             modifiers: Modifiers::NONE,
             leds: KeyboardLedStatus::empty(),
+
+            key_repeat: None,
             pending_event,
             pending_mouse,
+            pointer_surface,
+
             pending_first_configure: Some(pending_first_configure),
             frame_callback: None,
+
+            text_cursor: None,
+
+            config,
+
             title: None,
-            gl_state: None,
+
             wegl_surface: None,
-            text_cursor: None,
-            appearance: Appearance::Light,
+            gl_state: None,
         }));
 
         let window_handle = Window::Wayland(WaylandWindow(window_id));
+
         inner
             .borrow_mut()
             .events
             .assign_window(window_handle.clone());
 
-        conn.windows.borrow_mut().insert(window_id, inner.clone());
+        {
+            let windows = &conn.wayland_state.borrow().windows;
+            windows.borrow_mut().insert(window_id, inner.clone());
+        };
 
         wait_configure.recv().await?;
 
@@ -395,116 +324,312 @@ impl WaylandWindow {
     }
 }
 
-unsafe impl HasRawDisplayHandle for WaylandWindowInner {
-    fn raw_display_handle(&self) -> RawDisplayHandle {
-        let mut handle = WaylandDisplayHandle::empty();
-        let conn = WaylandConnection::get().unwrap().wayland();
-        handle.display = conn.display.borrow().c_ptr() as _;
-        RawDisplayHandle::Wayland(handle)
+#[async_trait(?Send)]
+impl WindowOps for WaylandWindow {
+    fn show(&self) {
+        WaylandConnection::with_window_inner(self.0, |inner| {
+            inner.show();
+            Ok(())
+        });
     }
-}
 
-unsafe impl HasRawWindowHandle for WaylandWindowInner {
-    fn raw_window_handle(&self) -> RawWindowHandle {
-        let mut handle = WaylandWindowHandle::empty();
-        handle.surface = self.surface.as_ref().c_ptr() as *mut _;
-        RawWindowHandle::Wayland(handle)
+    fn notify<T: Any + Send + Sync>(&self, t: T)
+    where
+        Self: Sized,
+    {
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            inner
+                .events
+                .dispatch(WindowEvent::Notification(Box::new(t)));
+            Ok(())
+        });
     }
-}
 
-impl WaylandWindowInner {
-    pub(crate) fn appearance_changed(&mut self, appearance: Appearance) {
-        if appearance != self.appearance {
-            self.appearance = appearance;
-            self.events
-                .dispatch(WindowEvent::AppearanceChanged(appearance));
-        }
+    async fn enable_opengl(&self) -> anyhow::Result<Rc<glium::backend::Context>> {
+        let window = self.0;
+        promise::spawn::spawn(async move {
+            if let Some(handle) = Connection::get().unwrap().wayland().window_by_id(window) {
+                let mut inner = handle.borrow_mut();
+                inner.enable_opengl()
+            } else {
+                anyhow::bail!("invalid window");
+            }
+        })
+        .await
     }
 
-    pub(crate) fn keyboard_event(&mut self, event: WlKeyboardEvent) {
-        let conn = WaylandConnection::get().unwrap().wayland();
-        let mut mapper = conn.keyboard_mapper.borrow_mut();
-        let mapper = mapper.as_mut().expect("no keymap");
+    fn hide(&self) {
+        todo!()
+    }
 
-        match event {
-            WlKeyboardEvent::Enter { keys, .. } => {
-                // Keys is bytes, but is really u32 keysyms
-                let key_codes = keys
-                    .chunks_exact(4)
-                    .map(|c| u32::from_ne_bytes(c.try_into().unwrap()))
-                    .collect::<Vec<_>>();
+    fn close(&self) {
+        WaylandConnection::with_window_inner(self.0, |inner| {
+            inner.close();
+            Ok(())
+        });
+    }
 
-                log::trace!("keyboard event: Enter with keys: {:?}", key_codes);
+    fn set_cursor(&self, cursor: Option<MouseCursor>) {
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            inner.set_cursor(cursor);
+            Ok(())
+        });
+    }
 
-                self.emit_focus(mapper, true);
-            }
-            WlKeyboardEvent::Leave { .. } => {
-                self.emit_focus(mapper, false);
-            }
-            WlKeyboardEvent::Key { key, state, .. } => {
-                if let Some(event) =
-                    mapper.process_wayland_key(key, state == KeyState::Pressed, &mut self.events)
-                {
-                    let rep = Arc::new(Mutex::new(KeyRepeatState {
-                        when: Instant::now(),
-                        event,
-                    }));
-                    self.key_repeat.replace((key, Arc::clone(&rep)));
-                    KeyRepeatState::schedule(rep, self.window_id);
-                } else if let Some((cur_key, _)) = self.key_repeat.as_ref() {
-                    // important to check that it's the same key, because the release of the previously
-                    // repeated key can come right after the press of the newly held key
-                    if *cur_key == key {
-                        self.key_repeat.take();
-                    }
-                }
-            }
-            WlKeyboardEvent::Modifiers {
-                mods_depressed,
-                mods_latched,
-                mods_locked,
-                group,
-                ..
-            } => {
-                mapper.update_modifier_state(mods_depressed, mods_latched, mods_locked, group);
+    fn invalidate(&self) {
+        WaylandConnection::with_window_inner(self.0, |inner| {
+            inner.invalidate();
+            Ok(())
+        });
+    }
 
-                let mods = mapper.get_key_modifiers();
-                let leds = mapper.get_led_status();
+    fn set_text_cursor_position(&self, cursor: Rect) {
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            inner.set_text_cursor_position(cursor);
+            Ok(())
+        });
+    }
 
-                let changed = (mods != self.modifiers) || (leds != self.leds);
+    fn set_title(&self, title: &str) {
+        let title = title.to_owned();
+        WaylandConnection::with_window_inner(self.0, |inner| {
+            inner.set_title(title);
+            Ok(())
+        });
+    }
 
-                self.modifiers = mapper.get_key_modifiers();
-                self.leds = mapper.get_led_status();
+    fn set_inner_size(&self, _width: usize, _height: usize) {
+        todo!()
+    }
 
-                if changed {
-                    self.events
-                        .dispatch(WindowEvent::AdviseModifiersLedStatus(mods, leds));
+    fn set_resize_increments(&self, incr: ResizeIncrement) {
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            Ok(inner.set_resize_increments(incr))
+        });
+    }
+
+    fn get_clipboard(&self, clipboard: Clipboard) -> Future<String> {
+        let mut promise = Promise::new();
+        let future = promise.get_future().unwrap();
+        let promise = Arc::new(Mutex::new(promise));
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            let read = inner
+                .copy_and_paste
+                .lock()
+                .unwrap()
+                .get_clipboard_data(clipboard)?;
+            let promise = Arc::clone(&promise);
+            std::thread::spawn(move || {
+                let mut promise = promise.lock().unwrap();
+                match read_pipe_with_timeout(read) {
+                    Ok(result) => {
+                        // Normalize the text to unix line endings, otherwise
+                        // copying from eg: firefox inserts a lot of blank
+                        // lines, and that is super annoying.
+                        promise.ok(result.replace("\r\n", "\n"));
+                    }
+                    Err(e) => {
+                        log::error!("while reading clipboard: {}", e);
+                        promise.err(anyhow!("{}", e));
+                    }
+                };
+            });
+            Ok(())
+        });
+        future
+    }
+
+    fn set_clipboard(&self, clipboard: Clipboard, text: String) {
+        WaylandConnection::with_window_inner(self.0, move |inner| {
+            inner
+                .copy_and_paste
+                .lock()
+                .unwrap()
+                .set_clipboard_data(clipboard, text);
+            Ok(())
+        });
+    }
+}
+#[derive(Default, Clone, Debug)]
+pub(crate) struct PendingEvent {
+    pub(crate) close: bool,
+    pub(crate) had_configure_event: bool,
+    refresh_decorations: bool,
+    // XXX: configure and window_configure could probably be combined, but right now configure only
+    // queues a new size, so it can be out of sync. Example would be maximizing and minimizing winodw
+    pub(crate) configure: Option<(u32, u32)>,
+    pub(crate) window_configure: Option<WindowConfigure>,
+    pub(crate) dpi: Option<i32>,
+    pub(crate) window_state: Option<WindowState>,
+}
+
+pub(crate) fn read_pipe_with_timeout(mut file: FileDescriptor) -> anyhow::Result<String> {
+    let mut result = Vec::new();
+
+    file.set_non_blocking(true)?;
+    let mut pfd = libc::pollfd {
+        fd: file.as_raw_fd(),
+        events: libc::POLLIN,
+        revents: 0,
+    };
+
+    let mut buf = [0u8; 8192];
+
+    loop {
+        if unsafe { libc::poll(&mut pfd, 1, 3000) == 1 } {
+            match file.read(&mut buf) {
+                Ok(size) if size == 0 => {
+                    break;
+                }
+                Ok(size) => {
+                    result.extend_from_slice(&buf[..size]);
                 }
+                Err(e) => bail!("error reading from pipe: {}", e),
             }
-            _ => {}
+        } else {
+            bail!("timed out reading from pipe");
         }
     }
 
-    fn emit_focus(&mut self, mapper: &mut KeyboardWithFallback, focused: bool) {
-        // Clear the modifiers when we change focus, otherwise weird
-        // things can happen.  For instance, if we lost focus because
-        // CTRL+SHIFT+N was pressed to spawn a new window, we'd be
-        // left stuck with CTRL+SHIFT held down and the window would
-        // be left in a broken state.
+    Ok(String::from_utf8(result)?)
+}
 
-        self.modifiers = Modifiers::NONE;
-        mapper.update_modifier_state(0, 0, 0, 0);
-        self.key_repeat.take();
-        self.events.dispatch(WindowEvent::FocusChanged(focused));
-        self.text_cursor.take();
+pub struct WaylandWindowInner {
+    pub(crate) events: WindowEventSender,
+    surface_factor: f64,
+    copy_and_paste: Arc<Mutex<CopyAndPaste>>,
+    window: Option<XdgWindow>,
+    pub(super) window_frame: FallbackFrame<WaylandState>,
+    dimensions: Dimensions,
+    resize_increments: Option<ResizeIncrement>,
+    window_state: WindowState,
+    pointer_surface: WlSurface,
+    last_mouse_coords: Point,
+    mouse_buttons: MouseButtons,
+    hscroll_remainder: f64,
+    vscroll_remainder: f64,
+    modifiers: Modifiers,
+    leds: KeyboardLedStatus,
+    pub(super) key_repeat: Option<(u32, Arc<Mutex<KeyRepeatState>>)>,
+    pub(super) pending_event: Arc<Mutex<PendingEvent>>,
+    pub(super) pending_mouse: Arc<Mutex<PendingMouse>>,
+    pending_first_configure: Option<async_channel::Sender<()>>,
+    frame_callback: Option<WlCallback>,
+    invalidated: bool,
+    // font_config: Rc<FontConfiguration>,
+    text_cursor: Option<Rect>,
+    // appearance: Appearance,
+    config: ConfigHandle,
+    // cache the title for comparison to avoid spamming
+    // the compositor with updates that don't actually change it
+    title: Option<String>,
+    // wegl_surface is listed before gl_state because it
+    // must be dropped before gl_state otherwise the underlying
+    // libraries will segfault on shutdown
+    wegl_surface: Option<WlEglSurface>,
+    gl_state: Option<Rc<glium::backend::Context>>,
+}
+
+impl WaylandWindowInner {
+    fn close(&mut self) {
+        self.events.dispatch(WindowEvent::Destroyed);
+        self.window.take();
+    }
+
+    fn show(&mut self) {
+        log::trace!("WaylandWindowInner show: {:?}", self.window);
+        if self.window.is_none() {
+            return;
+        }
+
+        self.do_paint().unwrap();
+    }
+
+    fn refresh_frame(&mut self) {
+        if let Some(window) = self.window.as_mut() {
+            if self.window_frame.is_dirty() && !self.window_frame.is_hidden() {
+                self.window_frame.draw();
+            }
+            window.wl_surface().commit();
+        }
+    }
+
+    fn enable_opengl(&mut self) -> anyhow::Result<Rc<glium::backend::Context>> {
+        let wayland_conn = Connection::get().unwrap().wayland();
+        let mut wegl_surface = None;
+
+        log::trace!("Enable opengl");
+
+        let gl_state = if !egl_is_available() {
+            Err(anyhow!("!egl_is_available"))
+        } else {
+            let window = self
+                .window
+                .as_ref()
+                .ok_or(anyhow!("Window does not exist"))?;
+            let object_id = window.wl_surface().id();
+
+            wegl_surface = Some(WlEglSurface::new(
+                object_id,
+                self.dimensions.pixel_width as i32,
+                self.dimensions.pixel_height as i32,
+            )?);
+
+            log::trace!("WEGL Surface here {:?}", wegl_surface);
+
+            match wayland_conn.gl_connection.borrow().as_ref() {
+                Some(glconn) => crate::egl::GlState::create_wayland_with_existing_connection(
+                    glconn,
+                    wegl_surface.as_ref().unwrap(),
+                ),
+                None => crate::egl::GlState::create_wayland(
+                    Some(wayland_conn.connection.backend().display_ptr() as *const _),
+                    wegl_surface.as_ref().unwrap(),
+                ),
+            }
+        };
+        let gl_state = gl_state.map(Rc::new).and_then(|state| unsafe {
+            wayland_conn
+                .gl_connection
+                .borrow_mut()
+                .replace(Rc::clone(state.get_connection()));
+            Ok(glium::backend::Context::new(
+                Rc::clone(&state),
+                true,
+                if cfg!(debug_assertions) {
+                    glium::debug::DebugCallbackBehavior::DebugMessageOnError
+                } else {
+                    glium::debug::DebugCallbackBehavior::Ignore
+                },
+            )?)
+        })?;
+
+        self.gl_state.replace(gl_state.clone());
+        self.wegl_surface = wegl_surface;
+
+        Ok(gl_state)
+    }
+
+    fn get_dpi_factor(&self) -> f64 {
+        self.dimensions.dpi as f64 / crate::DEFAULT_DPI as f64
+    }
+
+    fn surface_to_pixels(&self, surface: i32) -> i32 {
+        (surface as f64 * self.get_dpi_factor()).ceil() as i32
     }
 
-    pub(crate) fn dispatch_dropped_files(&mut self, paths: Vec<PathBuf>) {
+    fn pixels_to_surface(&self, pixels: i32) -> i32 {
+        // Take care to round up, otherwise we can lose a pixel
+        // and that can effectively lose the final row of the
+        // terminal
+        ((pixels as f64) / self.get_dpi_factor()).ceil() as i32
+    }
+
+    pub(super) fn dispatch_dropped_files(&mut self, paths: Vec<PathBuf>) {
         self.events.dispatch(WindowEvent::DroppedFile(paths));
     }
 
     pub(crate) fn dispatch_pending_mouse(&mut self) {
-        // Dancing around the borrow checker and the call to self.refresh_frame()
         let pending_mouse = Arc::clone(&self.pending_mouse);
 
         if let Some((x, y)) = PendingMouse::coords(&pending_mouse) {
@@ -608,35 +733,21 @@ impl WaylandWindowInner {
         }
     }
 
-    fn get_dpi_factor(&self) -> f64 {
-        self.dimensions.dpi as f64 / crate::DEFAULT_DPI as f64
-    }
-
-    fn surface_to_pixels(&self, surface: i32) -> i32 {
-        (surface as f64 * self.get_dpi_factor()).ceil() as i32
-    }
-
-    fn pixels_to_surface(&self, pixels: i32) -> i32 {
-        // Take care to round up, otherwise we can lose a pixel
-        // and that can effectively lose the final row of the
-        // terminal
-        ((pixels as f64) / self.get_dpi_factor()).ceil() as i32
-    }
-
-    fn dispatch_pending_event(&mut self) {
+    pub(crate) fn dispatch_pending_event(&mut self) {
         let mut pending;
         {
             let mut pending_events = self.pending_event.lock().unwrap();
             pending = pending_events.clone();
             *pending_events = PendingEvent::default();
         }
+
         if pending.close {
             self.events.dispatch(WindowEvent::CloseRequested);
         }
 
         if let Some(window_state) = pending.window_state.take() {
             log::debug!(
-                "dispatch_pending_event self.window_state={:?} pending:{:?}",
+                "dispatch_pending_event self.window_state={:?}, pending:{:?}",
                 self.window_state,
                 window_state
             );
@@ -654,15 +765,23 @@ impl WaylandWindowInner {
             }
         }
 
+        if let Some(ref window_config) = pending.window_configure {
+            self.window_frame.update_state(window_config.state);
+            self.window_frame
+                .update_wm_capabilities(window_config.capabilities);
+        }
+
         if let Some((mut w, mut h)) = pending.configure.take() {
+            log::trace!("Pending configure: w:{w}, h{h} -- {:?}", self.window);
             if self.window.is_some() {
-                let factor = get_surface_scale_factor(&self.surface) as f64;
+                let surface_udata = SurfaceUserData::from_wl(self.surface());
+                let factor = surface_udata.surface_data.scale_factor() as f64;
                 let old_dimensions = self.dimensions;
 
                 // FIXME: teach this how to resolve dpi_by_screen
                 let dpi = self.config.dpi.unwrap_or(factor * crate::DEFAULT_DPI) as usize;
 
-                // Do this early because this affects surface_to_pixels/pixels_to_surface below!
+                // Do this early because this affects surface_to_pixels/pixels_to_surface
                 self.dimensions.dpi = dpi;
 
                 let mut pixel_width = self.surface_to_pixels(w.try_into().unwrap());
@@ -684,9 +803,23 @@ impl WaylandWindowInner {
                     }
                 }
 
-                // Update the window decoration size
-                self.window.as_mut().unwrap().resize(w, h);
-
+                log::trace!("Resizing frame");
+                let (width, height) = self.window_frame.subtract_borders(
+                    NonZeroU32::new(pixel_width as u32).unwrap(),
+                    NonZeroU32::new(pixel_height as u32).unwrap(),
+                );
+                // Clamp the size to at least one pixel.
+                let width = width.unwrap_or(NonZeroU32::new(1).unwrap());
+                let height = height.unwrap_or(NonZeroU32::new(1).unwrap());
+                self.window_frame.resize(width, height);
+                let (x, y) = self.window_frame.location();
+                let outer_size = self.window_frame.add_borders(width.get(), height.get());
+                self.window
+                    .as_mut()
+                    .unwrap()
+                    .xdg_surface()
+                    .set_window_geometry(x, y, outer_size.0 as i32, outer_size.1 as i32);
+                // }
                 // Compute the new pixel dimensions
                 let new_dimensions = Dimensions {
                     pixel_width: pixel_width.try_into().unwrap(),
@@ -723,23 +856,24 @@ impl WaylandWindowInner {
                     }
                     if self.surface_factor != factor {
                         let wayland_conn = Connection::get().unwrap().wayland();
-                        let mut pool = wayland_conn.mem_pool.borrow_mut();
+                        let wayland_state = wayland_conn.wayland_state.borrow();
+                        let mut pool = wayland_state.mem_pool.borrow_mut();
+
                         // Make a "fake" buffer with the right dimensions, as
                         // simply detaching the buffer can cause wlroots-derived
                         // compositors consider the window to be unconfigured.
-                        if let Ok((_bytes, buffer)) = pool.buffer(
+                        if let Ok((buffer, _bytes)) = pool.create_buffer(
                             factor as i32,
                             factor as i32,
                             (factor * 4.0) as i32,
                             wayland_client::protocol::wl_shm::Format::Argb8888,
                         ) {
-                            self.surface.attach(Some(&buffer), 0, 0);
-                            self.surface.set_buffer_scale(factor as i32);
+                            self.surface().attach(Some(buffer.wl_buffer()), 0, 0);
+                            self.surface().set_buffer_scale(factor as i32);
                             self.surface_factor = factor;
                         }
                     }
                 }
-
                 self.refresh_frame();
                 self.do_paint().unwrap();
             }
@@ -748,6 +882,7 @@ impl WaylandWindowInner {
             self.refresh_frame();
         }
         if pending.had_configure_event && self.window.is_some() {
+            log::debug!("Had configured an event");
             if let Some(notify) = self.pending_first_configure.take() {
                 // Allow window creation to complete
                 notify.try_send(()).ok();
@@ -755,64 +890,85 @@ impl WaylandWindowInner {
         }
     }
 
-    fn refresh_frame(&mut self) {
-        if let Some(window) = self.window.as_mut() {
-            window.refresh();
-            window.surface().commit();
+    fn set_cursor(&mut self, cursor: Option<MouseCursor>) {
+        let name = cursor.map_or("none", |cursor| match cursor {
+            MouseCursor::Arrow => "arrow",
+            MouseCursor::Hand => "hand",
+            MouseCursor::SizeUpDown => "ns-resize",
+            MouseCursor::SizeLeftRight => "ew-resize",
+            MouseCursor::Text => "xterm",
+        });
+        let conn = Connection::get().unwrap().wayland();
+        let state = conn.wayland_state.borrow_mut();
+        let (shm, pointer) =
+            RefMut::map_split(state, |s| (&mut s.shm, s.pointer.as_mut().unwrap()));
+
+        // Much different API in 0.18
+        if let Err(err) = pointer.set_cursor(
+            &conn.connection,
+            name,
+            shm.wl_shm(),
+            &self.pointer_surface,
+            1,
+        ) {
+            log::error!("set_cursor: {}", err);
         }
     }
 
-    fn enable_opengl(&mut self) -> anyhow::Result<Rc<glium::backend::Context>> {
-        let wayland_conn = Connection::get().unwrap().wayland();
-        let mut wegl_surface = None;
-
-        let gl_state = if !egl_is_available() {
-            Err(anyhow!("!egl_is_available"))
-        } else {
-            wegl_surface = Some(WlEglSurface::new(
-                &self.surface,
-                self.dimensions.pixel_width as i32,
-                self.dimensions.pixel_height as i32,
-            ));
+    fn invalidate(&mut self) {
+        if self.frame_callback.is_some() {
+            self.invalidated = true;
+            return;
+        }
+        self.do_paint().unwrap();
+    }
 
-            match wayland_conn.gl_connection.borrow().as_ref() {
-                Some(glconn) => crate::egl::GlState::create_wayland_with_existing_connection(
-                    glconn,
-                    wegl_surface.as_ref().unwrap(),
-                ),
-                None => crate::egl::GlState::create_wayland(
-                    Some(wayland_conn.display.borrow().get_display_ptr() as *const _),
-                    wegl_surface.as_ref().unwrap(),
-                ),
+    fn set_text_cursor_position(&mut self, rect: Rect) {
+        let conn = WaylandConnection::get().unwrap().wayland();
+        let state = conn.wayland_state.borrow();
+        let surface = self.surface().clone();
+        let active_surface_id = state.active_surface_id.borrow();
+        let surface_id = surface.id();
+
+        if let Some(active_surface_id) = active_surface_id.as_ref() {
+            if surface_id == active_surface_id.clone() {
+                if self.text_cursor.map(|prior| prior != rect).unwrap_or(true) {
+                    self.text_cursor.replace(rect);
+
+                    let surface_udata = SurfaceUserData::from_wl(&surface);
+                    let factor = surface_udata.surface_data().scale_factor();
+
+                    if let Some(text_input) = &state.text_input {
+                        if let Some(input) = text_input.get_text_input_for_surface(&surface) {
+                            input.set_cursor_rectangle(
+                                rect.min_x() as i32 / factor,
+                                rect.min_y() as i32 / factor,
+                                rect.width() as i32 / factor,
+                                rect.height() as i32 / factor,
+                            );
+                            input.commit();
+                        }
+                    }
+                }
             }
-        };
-        let gl_state = gl_state.map(Rc::new).and_then(|state| unsafe {
-            wayland_conn
-                .gl_connection
-                .borrow_mut()
-                .replace(Rc::clone(state.get_connection()));
-            Ok(glium::backend::Context::new(
-                Rc::clone(&state),
-                true,
-                if cfg!(debug_assertions) {
-                    glium::debug::DebugCallbackBehavior::DebugMessageOnError
-                } else {
-                    glium::debug::DebugCallbackBehavior::Ignore
-                },
-            )?)
-        })?;
-
-        self.gl_state.replace(gl_state.clone());
-        self.wegl_surface = wegl_surface;
-
-        Ok(gl_state)
+        }
     }
 
-    fn next_frame_is_ready(&mut self) {
-        self.frame_callback.take();
-        if self.invalidated {
-            self.do_paint().ok();
+    fn set_title(&mut self, title: String) {
+        if let Some(last_title) = self.title.as_ref() {
+            if last_title == &title {
+                return;
+            }
+        }
+        if let Some(window) = self.window.as_ref() {
+            window.set_title(title.clone());
         }
+        self.refresh_frame();
+        self.title = Some(title);
+    }
+
+    fn set_resize_increments(&mut self, incr: ResizeIncrement) {
+        self.resize_increments = Some(incr);
     }
 
     fn do_paint(&mut self) -> anyhow::Result<()> {
@@ -828,14 +984,12 @@ impl WaylandWindowInner {
 
         // Ask the compositor to wake us up when its time to paint the next frame,
         // note that this only happens _after_ the next commit
-        let window_id = self.window_id;
-        let callback = self.surface.frame();
-        callback.quick_assign(move |_source, _event, _data| {
-            WaylandConnection::with_window_inner(window_id, |inner| {
-                inner.next_frame_is_ready();
-                Ok(())
-            });
-        });
+        let conn = WaylandConnection::get().unwrap().wayland();
+        let qh = conn.event_queue.borrow().handle();
+
+        let callback = self.surface().frame(&qh, self.surface().clone());
+
+        log::trace!("do_paint - callback: {:?}", callback);
         self.frame_callback.replace(callback);
 
         // The repaint has the side of effect of committing the surface,
@@ -848,426 +1002,302 @@ impl WaylandWindowInner {
 
         Ok(())
     }
-}
-
-unsafe impl HasRawDisplayHandle for WaylandWindow {
-    fn raw_display_handle(&self) -> RawDisplayHandle {
-        let mut handle = WaylandDisplayHandle::empty();
-        let conn = WaylandConnection::get().unwrap().wayland();
-        handle.display = conn.display.borrow().c_ptr() as _;
-        RawDisplayHandle::Wayland(handle)
-    }
-}
-
-unsafe impl HasRawWindowHandle for WaylandWindow {
-    fn raw_window_handle(&self) -> RawWindowHandle {
-        let conn = Connection::get().expect("raw_window_handle only callable on main thread");
-        let handle = conn
-            .wayland()
-            .window_by_id(self.0)
-            .expect("window handle invalid!?");
-
-        let inner = handle.borrow();
-        inner.raw_window_handle()
-    }
-}
-
-#[async_trait(?Send)]
-impl WindowOps for WaylandWindow {
-    async fn enable_opengl(&self) -> anyhow::Result<Rc<glium::backend::Context>> {
-        let window = self.0;
-        promise::spawn::spawn(async move {
-            if let Some(handle) = Connection::get().unwrap().wayland().window_by_id(window) {
-                let mut inner = handle.borrow_mut();
-                inner.enable_opengl()
-            } else {
-                anyhow::bail!("invalid window");
-            }
-        })
-        .await
-    }
-
-    fn finish_frame(&self, frame: glium::Frame) -> anyhow::Result<()> {
-        frame.finish()?;
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.refresh_frame();
-            Ok(())
-        });
-        Ok(())
-    }
-
-    fn notify<T: Any + Send + Sync>(&self, t: T)
-    where
-        Self: Sized,
-    {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner
-                .events
-                .dispatch(WindowEvent::Notification(Box::new(t)));
-            Ok(())
-        });
-    }
-
-    fn close(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.close();
-            Ok(())
-        });
-    }
-
-    fn hide(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.hide();
-            Ok(())
-        });
-    }
-
-    fn toggle_fullscreen(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.toggle_fullscreen();
-            Ok(())
-        });
-    }
 
-    fn config_did_change(&self, config: &ConfigHandle) {
-        let config = config.clone();
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner.config_did_change(&config);
-            Ok(())
-        });
+    fn surface(&self) -> &WlSurface {
+        self.window
+            .as_ref()
+            .expect("Window should exist")
+            .wl_surface()
     }
 
-    fn focus(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.focus();
-            Ok(())
-        });
-    }
-
-    fn show(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.show();
-            Ok(())
-        });
-    }
-
-    fn set_cursor(&self, cursor: Option<MouseCursor>) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner.set_cursor(cursor);
-            Ok(())
-        });
-    }
-
-    fn invalidate(&self) {
-        WaylandConnection::with_window_inner(self.0, |inner| {
-            inner.invalidate();
-            Ok(())
-        });
+    pub(crate) fn next_frame_is_ready(&mut self) {
+        self.frame_callback.take();
+        if self.invalidated {
+            self.do_paint().ok();
+        }
     }
 
-    fn set_text_cursor_position(&self, cursor: Rect) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner.set_text_cursor_position(cursor);
-            Ok(())
-        });
-    }
+    pub(crate) fn emit_focus(&mut self, mapper: &mut KeyboardWithFallback, focused: bool) {
+        // Clear the modifiers when we change focus, otherwise weird
+        // things can happen.  For instance, if we lost focus because
+        // CTRL+SHIFT+N was pressed to spawn a new window, we'd be
+        // left stuck with CTRL+SHIFT held down and the window would
+        // be left in a broken state.
 
-    fn set_title(&self, title: &str) {
-        let title = title.to_owned();
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner.set_title(title);
-            Ok(())
-        });
+        self.modifiers = Modifiers::NONE;
+        mapper.update_modifier_state(0, 0, 0, 0);
+        self.key_repeat.take();
+        self.events.dispatch(WindowEvent::FocusChanged(focused));
+        self.text_cursor.take();
     }
 
-    fn maximize(&self) {
-        WaylandConnection::with_window_inner(self.0, move |inner| Ok(inner.maximize()));
-    }
+    pub(super) fn keyboard_event(
+        &mut self,
+        mapper: &mut KeyboardWithFallback,
+        event: WlKeyboardEvent,
+    ) {
+        match event {
+            WlKeyboardEvent::Enter { keys, .. } => {
+                let key_codes = keys
+                    .chunks_exact(4)
+                    .map(|c| u32::from_ne_bytes(c.try_into().unwrap()))
+                    .collect::<Vec<_>>();
+                log::trace!("keyboard event: Enter with keys: {:?}", key_codes);
+                self.emit_focus(mapper, true);
+            }
+            WlKeyboardEvent::Leave { .. } => {
+                self.emit_focus(mapper, false);
+            }
+            WlKeyboardEvent::Key { key, state, .. } => {
+                if let Some(event) = mapper.process_wayland_key(
+                    key,
+                    state.into_result().unwrap() == KeyState::Pressed,
+                    &mut self.events,
+                ) {
+                    let rep = Arc::new(Mutex::new(KeyRepeatState {
+                        when: Instant::now(),
+                        event,
+                    }));
+                    self.key_repeat.replace((key, Arc::clone(&rep)));
+                    let window_id = SurfaceUserData::from_wl(
+                        self.window
+                            .as_ref()
+                            .expect("window should exist")
+                            .wl_surface(),
+                    )
+                    .window_id;
+                    KeyRepeatState::schedule(rep, window_id);
+                } else if let Some((cur_key, _)) = self.key_repeat.as_ref() {
+                    // important to check that it's the same key, because the release of the previously
+                    // repeated key can come right after the press of the newly held key
+                    if *cur_key == key {
+                        self.key_repeat.take();
+                    }
+                }
+            }
+            WlKeyboardEvent::Modifiers {
+                mods_depressed,
+                mods_latched,
+                mods_locked,
+                group,
+                ..
+            } => {
+                mapper.update_modifier_state(mods_depressed, mods_latched, mods_locked, group);
 
-    fn restore(&self) {
-        WaylandConnection::with_window_inner(self.0, move |inner| Ok(inner.restore()));
-    }
+                let mods = mapper.get_key_modifiers();
+                let leds = mapper.get_led_status();
 
-    fn set_inner_size(&self, width: usize, height: usize) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            Ok(inner.set_inner_size(width, height))
-        });
-    }
+                let changed = (mods != self.modifiers) || (leds != self.leds);
 
-    fn request_drag_move(&self) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner.request_drag_move();
-            Ok(())
-        });
-    }
+                self.modifiers = mapper.get_key_modifiers();
+                self.leds = mapper.get_led_status();
 
-    fn set_resize_increments(&self, incr: ResizeIncrement) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            Ok(inner.set_resize_increments(incr))
-        });
+                if changed {
+                    self.events
+                        .dispatch(WindowEvent::AdviseModifiersLedStatus(mods, leds));
+                }
+            }
+            _ => {}
+        }
     }
 
-    fn get_clipboard(&self, clipboard: Clipboard) -> Future<String> {
-        let mut promise = Promise::new();
-        let future = promise.get_future().unwrap();
-        let promise = Arc::new(Mutex::new(promise));
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            let read = inner
-                .copy_and_paste
-                .lock()
-                .unwrap()
-                .get_clipboard_data(clipboard)?;
-            let promise = Arc::clone(&promise);
-            std::thread::spawn(move || {
-                let mut promise = promise.lock().unwrap();
-                match read_pipe_with_timeout(read) {
-                    Ok(result) => {
-                        // Normalize the text to unix line endings, otherwise
-                        // copying from eg: firefox inserts a lot of blank
-                        // lines, and that is super annoying.
-                        promise.ok(result.replace("\r\n", "\n"));
-                    }
-                    Err(e) => {
-                        log::error!("while reading clipboard: {}", e);
-                        promise.err(anyhow!("{}", e));
-                    }
-                };
-            });
-            Ok(())
-        });
-        future
+    pub(super) fn frame_action(&mut self, pointer: &WlPointer, serial: u32, action: FrameAction) {
+        let pointer_data = pointer.data::<PointerUserData>().unwrap();
+        let seat = pointer_data.pdata.seat();
+        match action {
+            FrameAction::Close => self.events.dispatch(WindowEvent::CloseRequested),
+            FrameAction::Minimize => self.window.as_ref().unwrap().set_minimized(),
+            FrameAction::Maximize => self.window.as_ref().unwrap().set_maximized(),
+            FrameAction::UnMaximize => self.window.as_ref().unwrap().unset_maximized(),
+            FrameAction::ShowMenu(x, y) => {
+                self.window
+                    .as_ref()
+                    .unwrap()
+                    .show_window_menu(seat, serial, (x, y))
+            }
+            FrameAction::Resize(edge) => self.window.as_ref().unwrap().resize(seat, serial, edge),
+            FrameAction::Move => self.window.as_ref().unwrap().move_(seat, serial),
+        }
     }
+}
 
-    fn set_clipboard(&self, clipboard: Clipboard, text: String) {
-        WaylandConnection::with_window_inner(self.0, move |inner| {
-            inner
-                .copy_and_paste
-                .lock()
-                .unwrap()
-                .set_clipboard_data(clipboard, text);
-            Ok(())
-        });
+impl WaylandState {
+    pub(super) fn window_by_id(&self, window_id: usize) -> Option<Rc<RefCell<WaylandWindowInner>>> {
+        self.windows.borrow().get(&window_id).map(Rc::clone)
     }
-}
 
-pub(crate) fn read_pipe_with_timeout(mut file: FileDescriptor) -> anyhow::Result<String> {
-    let mut result = Vec::new();
+    fn handle_window_event(&self, window: &XdgWindow, event: WaylandWindowEvent) {
+        let surface_data = SurfaceUserData::from_wl(window.wl_surface());
+        let window_id = surface_data.window_id;
 
-    file.set_non_blocking(true)?;
-    let mut pfd = libc::pollfd {
-        fd: file.as_raw_fd(),
-        events: libc::POLLIN,
-        revents: 0,
-    };
+        let window_inner = self
+            .window_by_id(window_id)
+            .expect("Inner Window should exist");
 
-    let mut buf = [0u8; 8192];
+        let p = window_inner.borrow().pending_event.clone();
+        let mut pending_event = p.lock().unwrap();
 
-    loop {
-        if unsafe { libc::poll(&mut pfd, 1, 3000) == 1 } {
-            match file.read(&mut buf) {
-                Ok(size) if size == 0 => {
-                    break;
-                }
-                Ok(size) => {
-                    result.extend_from_slice(&buf[..size]);
+        let changed = match event {
+            WaylandWindowEvent::Close => {
+                // TODO: This should the new queue function
+                // p.queue_close()
+                if !pending_event.close {
+                    pending_event.close = true;
+                    true
+                } else {
+                    false
                 }
-                Err(e) => bail!("error reading from pipe: {}", e),
             }
-        } else {
-            bail!("timed out reading from pipe");
-        }
-    }
+            WaylandWindowEvent::Request(configure) => {
+                pending_event.window_configure.replace(configure.clone());
+                // TODO: This should the new queue function
+                // p.queue_configure(&configure)
+                //
+                let mut changed;
+                pending_event.had_configure_event = true;
+                if let (Some(w), Some(h)) = configure.new_size {
+                    changed = pending_event.configure.is_none();
+                    pending_event.configure.replace((w.get(), h.get()));
+                } else {
+                    changed = true;
+                }
 
-    Ok(String::from_utf8(result)?)
-}
+                let mut state = WindowState::default();
+                if configure.state.contains(SCTKWindowState::FULLSCREEN) {
+                    state |= WindowState::FULL_SCREEN;
+                }
+                let fs_bits = SCTKWindowState::MAXIMIZED
+                    | SCTKWindowState::TILED_LEFT
+                    | SCTKWindowState::TILED_RIGHT
+                    | SCTKWindowState::TILED_TOP
+                    | SCTKWindowState::TILED_BOTTOM;
+                if !((configure.state & fs_bits).is_empty()) {
+                    state |= WindowState::MAXIMIZED;
+                }
 
-impl WaylandWindowInner {
-    fn close(&mut self) {
-        self.events.dispatch(WindowEvent::Destroyed);
-        self.window.take();
-    }
+                log::debug!(
+                    "Config: self.window_state={:?}, states: {:?} {:?}",
+                    pending_event.window_state,
+                    state,
+                    configure.state
+                );
 
-    fn hide(&mut self) {
-        if let Some(window) = self.window.as_ref() {
-            window.set_minimized();
-        }
-    }
+                if pending_event.window_state.is_none() && state != WindowState::default() {
+                    changed = true;
+                }
 
-    fn toggle_fullscreen(&mut self) {
-        if let Some(window) = self.window.as_ref() {
-            if self.window_state.contains(WindowState::FULL_SCREEN) {
-                window.unset_fullscreen();
-            } else {
-                window.set_fullscreen(None);
+                pending_event.window_state.replace(state);
+                changed
             }
+        };
+        if changed {
+            WaylandConnection::with_window_inner(window_id, move |inner| {
+                inner.dispatch_pending_event();
+                Ok(())
+            });
         }
     }
+}
 
-    fn focus(&mut self) {
-        log::debug!("Wayland doesn't support applications changing focus");
-    }
-
-    fn show(&mut self) {
-        if self.window.is_none() {
-            return;
-        }
-        // The window won't be visible until we've done our first paint,
-        // so we unconditionally queue a NeedRepaint event
-        self.do_paint().unwrap();
-    }
-
-    fn set_cursor(&mut self, cursor: Option<MouseCursor>) {
-        let names: &[&str] = match cursor {
-            Some(MouseCursor::Arrow) => &["arrow"],
-            Some(MouseCursor::Hand) => &["hand"],
-            Some(MouseCursor::SizeUpDown) => &["ns-resize"],
-            Some(MouseCursor::SizeLeftRight) => &["ew-resize"],
-            Some(MouseCursor::Text) => &["xterm"],
-            None => &[],
-        };
-        let conn = Connection::get().unwrap().wayland();
-        conn.pointer.borrow().set_cursor(names, None);
+impl CompositorHandler for WaylandState {
+    fn scale_factor_changed(
+        &mut self,
+        _conn: &WConnection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        _surface: &wayland_client::protocol::wl_surface::WlSurface,
+        _new_factor: i32,
+    ) {
+        // We do nothing, we get the scale_factor from surface_data
     }
 
-    fn invalidate(&mut self) {
-        if self.frame_callback.is_some() {
-            self.invalidated = true;
-            return;
-        }
-        self.do_paint().unwrap();
+    fn frame(
+        &mut self,
+        _conn: &WConnection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        surface: &wayland_client::protocol::wl_surface::WlSurface,
+        _time: u32,
+    ) {
+        log::trace!("frame: CompositorHandler");
+        let surface_data = SurfaceUserData::from_wl(surface);
+        let window_id = surface_data.window_id;
+
+        WaylandConnection::with_window_inner(window_id, |inner| {
+            inner.next_frame_is_ready();
+            Ok(())
+        });
     }
+}
 
-    fn maximize(&mut self) {
-        if let Some(window) = self.window.as_mut() {
-            window.set_maximized();
-        }
+impl WindowHandler for WaylandState {
+    fn request_close(
+        &mut self,
+        _conn: &WConnection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        window: &XdgWindow,
+    ) {
+        self.handle_window_event(window, WaylandWindowEvent::Close);
     }
 
-    fn restore(&mut self) {
-        if let Some(window) = self.window.as_mut() {
-            window.unset_maximized();
-        }
+    fn configure(
+        &mut self,
+        _conn: &WConnection,
+        _qh: &wayland_client::QueueHandle<Self>,
+        window: &XdgWindow,
+        configure: WindowConfigure,
+        _serial: u32,
+    ) {
+        self.handle_window_event(window, WaylandWindowEvent::Request(configure));
     }
+}
 
-    fn set_inner_size(&mut self, width: usize, height: usize) -> Dimensions {
-        let pixel_width = width as i32;
-        let pixel_height = height as i32;
-        let surface_width = self.pixels_to_surface(pixel_width) as u32;
-        let surface_height = self.pixels_to_surface(pixel_height) as u32;
-        // window.resize() doesn't generate a configure event,
-        // so we're going to fake one up, otherwise the window
-        // contents don't reflect the real size until eg:
-        // the focus is changed.
-        self.pending_event
-            .lock()
-            .unwrap()
-            .configure
-            .replace((surface_width, surface_height));
-        // apply the synthetic configure event to the inner surfaces
-        self.dispatch_pending_event();
-
-        // and update the window decorations
-        if let Some(window) = self.window.as_mut() {
-            window.resize(surface_width, surface_height);
-            // The resize must be followed by a refresh call.
-            window.refresh();
-            // In addition, resize doesn't take effect until
-            // the suface is commited
-            window.surface().commit();
-        }
+pub(super) struct SurfaceUserData {
+    surface_data: SurfaceData,
+    pub(super) window_id: usize,
+}
 
-        let factor = get_surface_scale_factor(&self.surface);
-        Dimensions {
-            pixel_width: pixel_width as _,
-            pixel_height: pixel_height as _,
-            dpi: self
-                .config
-                .dpi
-                .unwrap_or(factor as f64 * crate::DEFAULT_DPI) as usize,
-        }
+impl SurfaceUserData {
+    pub(super) fn from_wl(wl: &WlSurface) -> &Self {
+        wl.data()
+            .expect("User data should be associated with WlSurface")
     }
-
-    fn request_drag_move(&self) {
-        if let Some(window) = self.window.as_ref() {
-            let conn = Connection::get().unwrap().wayland();
-            let serial = *conn.last_serial.borrow();
-            window.start_interactive_move(&conn.pointer.borrow().seat, serial);
-        }
+    pub(super) fn try_from_wl(wl: &WlSurface) -> Option<&SurfaceUserData> {
+        wl.data()
     }
+}
 
-    fn set_text_cursor_position(&mut self, rect: Rect) {
-        let surface_id = wl_id(&*self.surface);
-        let conn = Connection::get().unwrap().wayland();
-        if surface_id == *conn.active_surface_id.borrow() {
-            if self.text_cursor.map(|prior| prior != rect).unwrap_or(true) {
-                self.text_cursor.replace(rect);
-                let factor = get_surface_scale_factor(&self.surface);
-
-                conn.environment.with_inner(|env| {
-                    if let Some(input) = env
-                        .input_handler()
-                        .get_text_input_for_surface(&self.surface)
-                    {
-                        input.set_cursor_rectangle(
-                            rect.min_x() as i32 / factor,
-                            rect.min_y() as i32 / factor,
-                            rect.width() as i32 / factor,
-                            rect.height() as i32 / factor,
-                        );
-                        input.commit();
-                    }
-                });
-            }
-        }
+impl SurfaceDataExt for SurfaceUserData {
+    fn surface_data(&self) -> &SurfaceData {
+        &self.surface_data
     }
+}
 
-    /// Change the title for the window manager
-    fn set_title(&mut self, title: String) {
-        if let Some(last_title) = self.title.as_ref() {
-            if last_title == &title {
-                return;
-            }
-        }
-        if let Some(window) = self.window.as_ref() {
-            window.set_title(title.clone());
-        }
-        self.refresh_frame();
-        self.title = Some(title);
+unsafe impl HasRawWindowHandle for WaylandWindowInner {
+    fn raw_window_handle(&self) -> RawWindowHandle {
+        let mut handle = WaylandWindowHandle::empty();
+        let surface = self.surface();
+        handle.surface = surface.id().as_ptr() as *mut _;
+        RawWindowHandle::Wayland(handle)
     }
+}
 
-    fn set_resize_increments(&mut self, incr: ResizeIncrement) {
-        self.resize_increments = Some(incr);
+unsafe impl HasRawDisplayHandle for WaylandWindow {
+    fn raw_display_handle(&self) -> RawDisplayHandle {
+        let mut handle = WaylandDisplayHandle::empty();
+        let conn = WaylandConnection::get().unwrap().wayland();
+        handle.display = conn.connection.backend().display_ptr() as *mut _;
+        RawDisplayHandle::Wayland(handle)
     }
+}
 
-    fn config_did_change(&mut self, config: &ConfigHandle) {
-        let dpi_changed =
-            self.config.dpi != config.dpi || self.config.dpi_by_screen != config.dpi_by_screen;
-        self.config = config.clone();
-        if let Some(window) = self.window.as_mut() {
-            window.set_frame_config(ConceptConfig {
-                font_config: Some(Rc::clone(&self.font_config)),
-                config: config.clone(),
-            });
-
-            if dpi_changed {
-                // Synthesize a Resized event; we'll figure out the actual
-                // dpi to use there.
-                {
-                    let mut pending = self.pending_event.lock().unwrap();
-                    if pending.configure.is_none() {
-                        pending.configure.replace((
-                            self.dimensions.pixel_width as u32,
-                            self.dimensions.pixel_height as u32,
-                        ));
-                    }
-                }
-                self.dispatch_pending_event();
-            }
+unsafe impl HasRawWindowHandle for WaylandWindow {
+    fn raw_window_handle(&self) -> RawWindowHandle {
+        let conn = Connection::get().expect("raw_window_handle only callable on main thread");
+        let handle = conn
+            .wayland()
+            .window_by_id(self.0)
+            .expect("window handle invalid!?");
 
-            // I tried re-applying the config to window.set_decorate
-            // here, but it crashed weston.  I figure that users
-            // would prefer to manually close wezterm to change
-            // this setting!
-        }
+        let inner = handle.borrow();
+        inner.raw_window_handle()
     }
 }
